<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <!-- CSP å†…å®¹å®‰å…¨ç­–ç•¥ -->
    <meta http-equiv="Content-Security-Policy" content="
        default-src 'self';
        script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net;
        style-src 'self' 'unsafe-inline';
        connect-src *;
        img-src 'self' data: https:;
        font-src 'self' https:;
    ">
    <title>EchoAI</title>
    <link rel="stylesheet" href="style.css?v=0.2">
</head>
<body>
    <!-- ç§»åŠ¨ç«¯é®ç½©å±‚ -->
    <div class="sidebar-overlay" onclick="toggleSidebar()"></div>

    <!-- ä¾§è¾¹æ  -->
    <div class="sidebar">
        <div class="feature-sections" id="featureSections">
            <div class="feature-section" data-feature="copywriting">
                <button class="feature-section-header" onclick="toggleFeatureSection('copywriting')">
                    <span>âœï¸ æ–‡æ¡ˆç”Ÿæˆ</span>
                    <span class="feature-section-arrow">â–¾</span>
                </button>
                <div class="history-list feature-history-list" id="historyList-copywriting"></div>
            </div>
            <div class="feature-section" data-feature="videoScript">
                <button class="feature-section-header" onclick="toggleFeatureSection('videoScript')">
                    <span>ğŸ¬ è§†é¢‘è„šæœ¬ä¼˜åŒ–</span>
                    <span class="feature-section-arrow">â–¾</span>
                </button>
                <div class="history-list feature-history-list" id="historyList-videoScript"></div>
            </div>
            <div class="feature-section" data-feature="roleplay">
                <button class="feature-section-header" onclick="toggleFeatureSection('roleplay')">
                    <span>ğŸ­ è§’è‰²æ‰®æ¼”</span>
                    <span class="feature-section-arrow">â–¾</span>
                </button>
                <div class="history-list feature-history-list" id="historyList-roleplay"></div>
            </div>
            <div class="feature-section" data-feature="qaTest">
                <button class="feature-section-header" onclick="toggleFeatureSection('qaTest')">
                    <span>ğŸ§  æŠ€èƒ½è®­ç»ƒ</span>
                    <span class="feature-section-arrow">â–¾</span>
                </button>
                <div class="history-list feature-history-list" id="historyList-qaTest"></div>
            </div>
        </div>
        <button class="sidebar-settings-btn" onclick="openSettings()">
            âš™ï¸ è®¾ç½®
        </button>
        <div class="version-tag">
            <strong style="font-size: 1.1em; display: block; margin-bottom: 5px;">EchoAI</strong>
            v0.3
        </div>
    </div>

    <!-- ä¸»ç•Œé¢ -->
    <div class="main-content">
        <div class="chat-header">
            <div class="header-left">
                <button class="toggle-btn" onclick="toggleSidebar()" title="åˆ‡æ¢ä¾§è¾¹æ ">â˜°</button>
                <div class="topic-wrapper">
                    <span id="currentTopicTitle" class="topic-title" title="å½“å‰è¯é¢˜">æ–°å¯¹è¯</span>
                    <span id="systemPromptHint" class="system-prompt-hint" onclick="editSystemPrompt()" title="ç‚¹å‡»ç¼–è¾‘ç³»ç»Ÿæç¤ºè¯">âœ¨ ç‚¹å‡»è®¾ç½®åŠ©æ‰‹è§’è‰²</span>
                </div>
            </div>
            <div class="header-right">
                <select id="headerModelSelect" class="header-model-select" title="é€‰æ‹©æ¨¡å‹" onchange="onHeaderModelChange(this.value)">
                    <option value="">åŠ è½½ä¸­...</option>
                </select>
                <button class="announcement-btn" onclick="openAnnouncement()" title="å…¬å‘Š">ğŸ“¢</button>
            </div>
        </div>

        <div id="skillTrainingDashboard" class="skill-training-dashboard" style="display:none;">
            <div class="skill-dashboard-title" id="skillDashboardTitle">ğŸ§  æŠ€èƒ½è®­ç»ƒè¿›è¡Œä¸­</div>
            <div class="skill-dashboard-meta" id="skillDashboardMeta">å·²ç­” 0 é¢˜ Â· æŒæ¡åº¦ 0 åˆ†</div>
            <div class="skill-dashboard-track">
                <div id="skillDashboardBar" class="skill-dashboard-bar"></div>
            </div>
        </div>
        
        <div class="chat-messages" id="chatMessages">
            <div class="message-container ai">
                <div class="avatar ai">AI</div>
                <div class="message-content">ä½ å¥½ï¼æˆ‘æ˜¯ AI åŠ©æ‰‹ã€‚ä»Šå¤©æœ‰ä»€ä¹ˆæˆ‘å¯ä»¥å¸®ä½ çš„å—ï¼Ÿè¯·å…ˆç‚¹å‡»å³ä¸Šè§’è®¾ç½®é…ç½® API Keyã€‚</div>
            </div>
        </div>
        
        <div class="input-area">
            <div class="input-wrapper">
                <input type="file" id="imageUpload" accept="image/*" style="display: none;" onchange="handleImageUpload(event)">
                <button class="attach-btn" onclick="document.getElementById('imageUpload').click()" title="ä¸Šä¼ å›¾ç‰‡">ğŸ“</button>
                <input type="text" id="userInput" placeholder="è¾“å…¥æ¶ˆæ¯..." onkeypress="handleKeyPress(event)">
                <button onclick="sendMessage()" id="sendBtn" class="send-btn">å‘é€</button>
            </div>
            <div id="imagePreviewContainer" class="image-preview-container" style="display: none;">
                <div class="image-preview-wrapper">
                    <img id="imagePreview" src="" alt="é¢„è§ˆå›¾ç‰‡">
                    <button class="remove-image-btn" onclick="removeImage()" title="ç§»é™¤å›¾ç‰‡">Ã—</button>
                </div>
            </div>
            <div class="input-stats">
                <span id="contextInfo" title="ä¸Šä¸‹æ–‡æ¡æ•°">ğŸ“ ä¸Šä¸‹æ–‡: 0 æ¡</span>
                <span class="stats-divider">â€¢</span>
                <span id="tokenInfo" title="é¢„ä¼° Token æ•°">ğŸ”¤ é¢„ä¼°: ~0 tokens</span>
            </div>
        </div>
    </div>

    <!-- å›¾ç‰‡ç”Ÿæˆæ¨¡æ€æ¡† (ä¸“ä¸šæ¨¡å¼) -->
    <div id="imageGenModal" class="modal">
        <div class="modal-content image-gen-modal-content">
            <div class="modal-header">
                <span>ğŸ¨ ç»˜å›¾ä¸­å¿ƒ</span>
            </div>
            <div class="draw-entry-switcher">
                <button class="draw-entry-btn" onclick="startQuickDrawChat()">âš¡ æ™®é€šç»˜å›¾ï¼ˆå¯¹è¯ï¼‰</button>
                <button class="draw-entry-btn draw-entry-btn-active" disabled>ğŸ–¼ï¸ ä¸“ä¸šç»˜å›¾ï¼ˆé¢æ¿ï¼‰</button>
            </div>
            
            <!-- å›¾ç‰‡ç”Ÿæˆæ ‡ç­¾é¡µ -->
            <div class="image-gen-tabs">
                <button class="image-gen-tab active" onclick="switchImageGenTab('generate', this)">ğŸ¨ ç”Ÿæˆå›¾ç‰‡</button>
                <button class="image-gen-tab" onclick="switchImageGenTab('history', this)">ğŸ“œ ç”Ÿæˆè®°å½•</button>
            </div>
            
            <!-- ç”Ÿæˆå›¾ç‰‡é¢æ¿ -->
            <div id="imageGenPanel-generate" class="image-gen-panel active">
                <div class="image-gen-body">
                    <div class="form-group">
                        <label>å›¾ç‰‡æè¿° (Prompt)</label>
                        <textarea id="imageGenPrompt" rows="4" placeholder="è¯·å°½é‡å®Œæ•´æè¿°ï¼šä¸»ä½“ + ç¯å¢ƒ + æ„å›¾ + å…‰çº¿ + é£æ ¼ + ç»†èŠ‚ã€‚&#10;ç¤ºä¾‹ï¼šä¸€åªæ©˜çŒ«è¶´åœ¨æœ¨çª—è¾¹ï¼Œåˆåé˜³å…‰æ–œå°„ï¼Œæµ…æ™¯æ·±ç‰¹å†™ï¼Œç”µå½±æ„Ÿæš–è‰²è°ƒï¼Œæ°´å½©æ’ç”»é£ï¼Œç»†èŠ‚æ¸…æ™°ã€‚"></textarea>
                        <p class="image-gen-hint">æç¤ºï¼šå¯åŠ å…¥é£æ ¼è¯ï¼ˆèµ›åšæœ‹å…‹/æ°´å½©/å†™å®ï¼‰ã€é•œå¤´è¯ï¼ˆç‰¹å†™/å¹¿è§’/ä¿¯æ‹ï¼‰ã€ç”»è´¨è¯ï¼ˆè¶…æ¸…/ç»†èŠ‚ä¸°å¯Œï¼‰æ¥æå‡æ•ˆæœã€‚</p>
                    </div>
                    <div class="form-group">
                        <label>å‚è€ƒå›¾ç‰‡ (ä»¥å›¾ç”Ÿå›¾/å«å›¾)</label>
                        <div class="image-gen-upload">
                            <input type="file" id="imageGenUpload" accept="image/*" multiple style="display:none" onchange="handleImageGenUpload(event)">
                            <div id="imageGenUploadArea" class="image-gen-upload-area" onclick="document.getElementById('imageGenUpload').click()">
                                <div class="image-gen-upload-text">
                                    <span style="font-size: 2em; display: block; margin-bottom: 5px;">ğŸ“·</span>
                                    ç‚¹å‡»æˆ–æ‹–æ‹½ä¸Šä¼ å‚è€ƒå›¾ç‰‡ï¼ˆæ”¯æŒå¤šå¼ ï¼‰
                                </div>
                            </div>
                            <div id="imageGenPreviewList" class="image-gen-preview-list" style="display:none;"></div>
                        </div>
                        <p style="font-size: 0.8em; color: #888; margin-top: 5px;">ä¸Šä¼ å›¾ç‰‡åï¼ŒAI å°†å‚è€ƒè¿™äº›å›¾ç‰‡çš„æ„å›¾æˆ–å†…å®¹è¿›è¡Œç”Ÿæˆã€‚</p>
                    </div>
                    <div class="form-group">
                        <label>ç”Ÿæˆæ¨¡å‹</label>
                        <select id="imageGenModel">
                            <option value="gemini-3-pro-image-preview" selected>gemini-3-pro-image-preview</option>
                        </select>
                    </div>
                    <button id="generateImageBtn" class="save-btn" onclick="generateImage()">ğŸ¨ å¼€å§‹ç”Ÿæˆ</button>
                    
                    <div id="imageGenLoading" class="image-gen-loading" style="display: none;">
                        <div class="loading-spinner"></div>
                        <span>æ­£åœ¨ç”Ÿæˆå›¾ç‰‡ï¼Œè¯·ç¨å€™...</span>
                    </div>
                    
                    <div id="imageGenResult" class="image-gen-result" style="display: none;">
                        <h4>ç”Ÿæˆç»“æœ</h4>
                        <img id="generatedImage" src="" alt="ç”Ÿæˆçš„å›¾ç‰‡" onclick="openImageModal(this.src)">
                        <div class="image-gen-actions">
                            <button onclick="downloadGeneratedImage()">ğŸ’¾ ä¸‹è½½</button>
                            <button onclick="useAsRefImage()" title="å°†æ­¤å›¾ä½œä¸ºå‚è€ƒå›¾ç»§ç»­ç”Ÿæˆ">ğŸ”„ ä½œä¸ºå‚è€ƒ</button>
                            <button onclick="regenerateImage()">ğŸ² é‡æ–°ç”Ÿæˆ</button>
                        </div>
                    </div>
                    
                    <div id="imageGenError" class="image-gen-error" style="display: none;">
                        <span id="imageGenErrorMsg"></span>
                    </div>
                </div>
            </div>
            
            <!-- ç”Ÿæˆè®°å½•é¢æ¿ -->
            <div id="imageGenPanel-history" class="image-gen-panel">
                <div class="image-gen-history">
                    <div class="image-history-sort">é»˜è®¤æŒ‰æ—¶é—´å€’åºå±•ç¤ºï¼ˆæœ€æ–°åœ¨å‰ï¼‰</div>
                    <div id="imageHistoryList" class="image-history-list">
                        <!-- å†å²è®°å½•åŠ¨æ€ç”Ÿæˆ -->
                    </div>
                    <div id="imageHistoryEmpty" class="image-history-empty">
                        <div style="font-size: 3em; margin-bottom: 15px;">ğŸ“­</div>
                        <p>æš‚æ— ç”Ÿæˆè®°å½•</p>
                        <p style="font-size: 0.85em; opacity: 0.7;">ç”Ÿæˆçš„å›¾ç‰‡å°†ä¿å­˜åœ¨è¿™é‡Œ</p>
                    </div>
                    <div class="image-history-actions" id="imageHistoryActions" style="display: none;">
                        <button onclick="clearImageHistory()" class="clear-history-btn">ğŸ—‘ï¸ æ¸…ç©ºè®°å½•</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- æŠ€èƒ½è®­ç»ƒè®¾ç½®æ¨¡æ€æ¡† -->
    <div id="skillTrainingModal" class="modal">
        <div class="modal-content skill-training-modal-content">
            <div class="modal-header">
                <span>ğŸ§  æŠ€èƒ½è®­ç»ƒè®¾ç½®</span>
            </div>
            <div class="form-group">
                <label for="skillTrainingInput">ä½ æƒ³å­¦ä¹ çš„æŠ€èƒ½</label>
                <input type="text" id="skillTrainingInput" placeholder="ä¾‹å¦‚ï¼šPython æ•°æ®åˆ†æã€è‹±è¯­è¯­æ³•ã€äº§å“è¿è¥">
            </div>
            <p class="skill-training-tip">ç¡®è®¤åä¼šè¿›å…¥æ— é™é¢˜è®­ç»ƒæ¨¡å¼ï¼ˆé€‰æ‹©é¢˜ / å¡«ç©ºé¢˜ï¼‰ï¼Œå¹¶åŠ¨æ€æ›´æ–°æŒæ¡åº¦åˆ†æ•°ä¸è¿›åº¦ã€‚</p>
            <button class="save-btn" onclick="confirmSkillTraining()">å¼€å§‹è®­ç»ƒ</button>
        </div>
    </div>

    <!-- å…¬å‘Šæ¨¡æ€æ¡† -->
    <div id="announcementModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span>ç³»ç»Ÿå…¬å‘Š</span>
                <!-- å…³é—­æŒ‰é’®å·²ç§»é™¤ï¼Œè¯·ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®å…³é—­ -->
            </div>
            <div class="announcement-text">
                <p>æ¬¢è¿ä½¿ç”¨ EchoAIï¼</p>
                <p>æœ¬ç³»ç»Ÿé›†æˆäº†æœ€æ–°çš„ AI æ¨¡å‹ï¼Œæ”¯æŒä¸Šä¸‹æ–‡å¯¹è¯ã€ä»£ç é«˜äº®ã€æµå¼è¾“å‡ºç­‰åŠŸèƒ½ã€‚</p>
                <p><strong>æœ€æ–°æ›´æ–° (v0.3)ï¼š</strong></p>
                <ul>
                    <li>ğŸ–¼ï¸ ä¸“ä¸šç»˜å›¾å‡çº§ï¼šæ”¯æŒå¤šå›¾å‚è€ƒ (ä»¥å›¾ç”Ÿå›¾/æ··å›¾)</li>
                    <li>ğŸ”„ äº¤äº’ä¼˜åŒ–ï¼šç”Ÿæˆç»“æœå¯ç›´æ¥ä½œä¸ºå‚è€ƒå›¾ç»§ç»­åˆ›ä½œ</li>
                </ul>
                <p><strong>å†å²æ›´æ–° (v0.2.1)ï¼š</strong></p>
                <ul>
                    <li>ğŸ–¼ï¸ åŒæ¨¡ç»˜å›¾ï¼šæ”¯æŒâ€œå¯¹è¯æ¨¡å¼â€å’Œâ€œä¸“ä¸šé¢æ¿â€ä¸¤ç§ç»˜å›¾æ–¹å¼</li>
                    <li> å«å›¾åŠŸèƒ½ï¼šä¸“ä¸šé¢æ¿æ”¯æŒä¸Šä¼ å‚è€ƒå›¾è¿›è¡Œä»¥å›¾ç”Ÿå›¾</li>
                </ul>
                <p><strong>å†å²æ›´æ–° (v0.2)ï¼š</strong></p>
                <ul>
                    <li>ğŸ¨ ç»˜å›¾å¯¹è¯æ¨¡å¼ï¼šå›¾ç‰‡ç”Ÿæˆå·²é›†æˆåˆ°å¯¹è¯ç•Œé¢</li>
                </ul>
                <p><strong>å†å²æ›´æ–° (v0.1)ï¼š</strong></p>
                <ul>
                    <li>ğŸ¨ AI å›¾ç‰‡ç”Ÿæˆï¼šæ”¯æŒä½¿ç”¨ Gemini æ¨¡å‹ç”Ÿæˆå›¾ç‰‡</li>
                </ul>
                <p><strong>å†å²æ›´æ–° (v0.03)ï¼š</strong></p>
                <ul>
                    <li>ğŸ­ æ–°å¢è§’è‰²é¢„è®¾ï¼š12 ç§å†…ç½®åŠ©æ‰‹è§’è‰²ä¸€é”®åˆ‡æ¢</li>
                    <li>ğŸ›¡ï¸ å®‰å…¨æ€§å‡çº§ï¼šå¤šå±‚é˜²æŠ¤æœºåˆ¶ä¿éšœæœåŠ¡ç¨³å®š</li>
                    <li>âœ¨ æ¶ˆæ¯æ“ä½œï¼šæ”¯æŒé‡æ–°ç”Ÿæˆã€åˆ é™¤å’Œå¤åˆ¶æ¶ˆæ¯</li>
                    <li>â³ åŠ è½½åŠ¨ç”»ï¼šAI æ€è€ƒæ—¶æ˜¾ç¤ºåŠ¨æ€æç¤º</li>
                    <li>ğŸ“± ç§»åŠ¨ç«¯ä¼˜åŒ–ï¼šæ›´å¥½çš„è§¦å±äº¤äº’ä½“éªŒ</li>
                </ul>
                <p style="margin-top: 20px; color: #666; font-size: 0.9em;">å¦‚é‡é—®é¢˜ï¼Œè¯·è”ç³»ç®¡ç†å‘˜æˆ–æŸ¥çœ‹ä¾§è¾¹æ è”ç³»æ–¹å¼ã€‚</p>
            </div>
            <button onclick="closeAnnouncement()" class="save-btn">æˆ‘çŸ¥é“äº†</button>
        </div>
    </div>

    <!-- è®¾ç½®æ¨¡æ€æ¡† -->
    <div id="settingsModal" class="modal">
        <div class="modal-content settings-modal-content">
            <div class="modal-header">
                <span>ç³»ç»Ÿè®¾ç½®</span>
            </div>
            
            <!-- è®¾ç½®æ ‡ç­¾é¡µ -->
            <div class="settings-tabs">
                <button class="settings-tab active" onclick="switchSettingsTab('model', this)">ğŸ¤– æ¨¡å‹é…ç½®</button>
                <button class="settings-tab" onclick="switchSettingsTab('session', this)">ğŸ§­ ä¼šè¯ç­–ç•¥</button>
                <button class="settings-tab" onclick="switchSettingsTab('sync', this)">â˜ï¸ æ•°æ®åŒæ­¥</button>
                <button class="settings-tab" onclick="switchSettingsTab('extension', this)">ğŸ”§ æ‰©å±•</button>
            </div>
            
            <!-- æ¨¡å‹é…ç½® -->
            <div id="settingsPanel-model" class="settings-panel active">
                <div class="form-group">
                    <label>API æ¸ é“</label>
                    <div class="api-channel-display">SH API</div>
                    <p style="font-size: 0.8em; color: #888; margin-top: 5px;">ç”¨äºè¿æ¥æ¨¡å‹æœåŠ¡ã€‚å¡«å†™ API Key åå¯å…ˆæµ‹è¯•è¿æ¥ï¼Œå†ä¿å­˜é…ç½®ã€‚</p>
                </div>
                <div class="form-group">
                    <label>API å¯†é’¥ (API Key)</label>
                    <input type="password" id="apiKey" placeholder="sk-...">
                    <div style="display: flex; align-items: center; gap: 10px; margin-top: 8px;">
                        <button type="button" class="secondary-btn" onclick="testApiConnection(this)">æµ‹è¯•è¿æ¥</button>
                        <span id="apiConnectionStatus" style="font-size: 0.82em; color: #777;">æœªæµ‹è¯•</span>
                    </div>
                </div>
                <div class="form-group">
                    <label>æ¨¡å‹åç§° (Model)</label>
                    <div style="display: flex; gap: 5px; margin-bottom: 5px;">
                        <input type="text" id="modelName" placeholder="deepseek-v3.2" style="flex: 1;">
                        <button onclick="fetchModels()" style="padding: 0 10px; background-color: #17a2b8; color: white; border: none; border-radius: 4px; cursor: pointer; white-space: nowrap;">è·å–åˆ—è¡¨</button>
                    </div>
                    <select id="modelSelect" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; display: none;" onchange="document.getElementById('modelName').value = this.value">
                        <option value="" disabled selected>è¯·é€‰æ‹©æ¨¡å‹...</option>
                    </select>
                    <p style="font-size: 0.8em; color: #888; margin-top: 5px;">æ”¯æŒä»æ¸ é“è¯»å–æ¨¡å‹åˆ—è¡¨ï¼Œä¹Ÿå¯æ‰‹åŠ¨è¾“å…¥ã€‚</p>
                </div>
                <div class="form-group">
                    <label>åœºæ™¯é¢„è®¾</label>
                    <div style="display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 8px;">
                        <button type="button" class="secondary-btn" onclick="applyModelPreset('creative')">âœï¸ åˆ›æ„å†™ä½œåå¥½</button>
                        <button type="button" class="secondary-btn" onclick="applyModelPreset('rigorous')">ğŸ“Š ä¸¥è°¨åˆ†æåå¥½</button>
                    </div>
                    <p style="font-size: 0.8em; color: #888; margin-top: 5px;">å¿«é€Ÿå¥—ç”¨å¸¸è§å‚æ•°ç»„åˆï¼ˆå¯ç»§ç»­å¾®è°ƒï¼‰ã€‚</p>
                </div>

                <div class="form-group">
                    <label>æ¨¡å‹ç»„åˆæ–¹æ¡ˆ</label>
                    <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                        <input type="text" id="profileNameInput" placeholder="ä¾‹å¦‚ï¼šå†™ä½œæ–¹æ¡ˆ" style="flex: 1;">
                        <button type="button" class="secondary-btn" onclick="saveModelProfile()">ä¿å­˜æ–¹æ¡ˆ</button>
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <select id="profileSelect" style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                            <option value="">æš‚æ— å·²ä¿å­˜æ–¹æ¡ˆ</option>
                        </select>
                        <button type="button" class="secondary-btn" onclick="loadModelProfile()">åŠ è½½</button>
                        <button type="button" class="secondary-btn danger" onclick="deleteModelProfile()">åˆ é™¤</button>
                    </div>
                </div>

                <div class="form-group">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                        <label style="margin: 0;">æ¨¡å‹æ¸©åº¦ (Temperature)</label>
                        <span id="tempValue" style="color: #666;">0.7</span>
                    </div>
                    <input type="range" id="tempRange" min="0" max="2" step="0.1" value="0.7" style="width: 100%" oninput="document.getElementById('tempValue').textContent = this.value">
                    <p style="font-size: 0.8em; color: #888; margin-top: 5px;">è¾ƒä½å€¼ä½¿è¾“å‡ºæ›´ç¡®å®šï¼Œè¾ƒé«˜å€¼ä½¿è¾“å‡ºæ›´éšæœº</p>
                </div>

                <div class="form-group">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                        <label style="margin: 0;">ä¸Šä¸‹æ–‡æ•° (Context)</label>
                        <span id="contextValue" style="color: #666;">10</span>
                    </div>
                    <input type="range" id="contextRange" min="0" max="20" step="1" value="10" style="width: 100%" oninput="document.getElementById('contextValue').textContent = this.value">
                    <p style="font-size: 0.8em; color: #888; margin-top: 5px;">å‘é€ç»™æ¨¡å‹çš„å†å²æ¶ˆæ¯æ•°é‡</p>
                </div>
            </div>

            <!-- ä¼šè¯ç­–ç•¥ -->
            <div id="settingsPanel-session" class="settings-panel">
                <div class="form-group">
                    <h4 style="margin: 0 0 6px 0; font-size: 0.95em; color: #555;">ä¼šè¯è¡Œä¸º</h4>
                    <p style="font-size: 0.8em; color: #888; margin: 0;">æ§åˆ¶æ ‡é¢˜ç”Ÿæˆã€æ¶ˆæ¯ä¿ç•™ç­–ç•¥å’Œå›å¤æ–¹å¼ã€‚</p>
                </div>

                <div class="form-group">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                        <label style="margin: 0;">æ ‡é¢˜é‡ç”Ÿæˆé—´éš” (è½®)</label>
                        <span id="titleRegenValue" style="color: #666;">5</span>
                    </div>
                    <input type="range" id="titleRegenRange" min="0" max="20" step="1" value="5" style="width: 100%" oninput="document.getElementById('titleRegenValue').textContent = this.value">
                    <p style="font-size: 0.8em; color: #888; margin-top: 5px;">æ¯éš”å¤šå°‘è½®å¯¹è¯è‡ªåŠ¨é‡æ–°ç”Ÿæˆæ ‡é¢˜ï¼ˆ0=ä»…é¦–æ¬¡ï¼‰</p>
                </div>

                <div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <label style="margin: 0">è‡ªåŠ¨åˆ é™¤æ—§æ¶ˆæ¯</label>
                        <p style="font-size: 0.8em; color: #888; margin: 3px 0 0 0;">æ¯æ¬¡å¯¹è¯ååˆ é™¤æœ€æ—©çš„ä¸€æ¡æ¶ˆæ¯</p>
                    </div>
                    <label class="switch">
                        <input type="checkbox" id="autoDeleteOldestToggle">
                        <span class="slider-toggle"></span>
                    </label>
                </div>

                <div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <label style="margin: 0">æµå¼è¾“å‡º (Stream)</label>
                        <p style="font-size: 0.8em; color: #888; margin: 3px 0 0 0;">å®æ—¶æ˜¾ç¤ºAIå›å¤å†…å®¹</p>
                    </div>
                    <label class="switch">
                        <input type="checkbox" id="streamToggle">
                        <span class="slider-toggle"></span>
                    </label>
                </div>

                <div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <label style="margin: 0">æœ€å¤§ Token æ•° (Max Tokens)</label>
                        <p style="font-size: 0.8em; color: #888; margin: 3px 0 0 0;">é™åˆ¶å•æ¬¡å›å¤é•¿åº¦</p>
                    </div>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <input type="number" id="maxTokensInput" placeholder="2048" style="width: 80px; padding: 6px; display: none;">
                        <label class="switch">
                            <input type="checkbox" id="maxTokensToggle" onchange="document.getElementById('maxTokensInput').style.display = this.checked ? 'block' : 'none'">
                            <span class="slider-toggle"></span>
                        </label>
                    </div>
                </div>
            </div>
            
            <!-- æ•°æ®åŒæ­¥ä¸å¤‡ä»½ -->
            <div id="settingsPanel-sync" class="settings-panel">
                <div class="form-group">
                    <h4 style="margin: 0 0 6px 0; font-size: 0.95em; color: #555;">WebDAV å¤šç«¯åŒæ­¥</h4>
                    <p style="font-size: 0.8em; color: #888; margin: 0;">é€‚ç”¨äºåœ¨ä¸åŒè®¾å¤‡åŒæ­¥èŠå¤©è®°å½•å’Œç”Ÿæˆå†å²ã€‚</p>
                </div>
                <div class="form-group">
                    <label>WebDAV åœ°å€</label>
                    <input type="text" id="webdavUrl" placeholder="https://example.com/remote.php/webdav">
                </div>
                <div class="form-group">
                    <label>ç”¨æˆ·å</label>
                    <input type="text" id="webdavUsername" placeholder="WebDAV ç”¨æˆ·å">
                </div>
                <div class="form-group">
                    <label>å¯†ç </label>
                    <input type="password" id="webdavPassword" placeholder="WebDAV å¯†ç ">
                </div>
                <div class="form-group">
                    <label>ç›®å½•è·¯å¾„ (å¯é€‰)</label>
                    <input type="text" id="webdavPath" placeholder="EchoAI/backup">
                </div>
                <div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <label style="margin: 0">è‡ªåŠ¨åŒæ­¥</label>
                        <p style="font-size: 0.8em; color: #888; margin: 3px 0 0 0;">ä¿å­˜è®¾ç½®åæŒ‰é—´éš”è‡ªåŠ¨æ‰§è¡Œ WebDAV åŒæ­¥</p>
                    </div>
                    <label class="switch">
                        <input type="checkbox" id="webdavAutoSyncToggle">
                        <span class="slider-toggle"></span>
                    </label>
                </div>
                <div class="form-group">
                    <label>è‡ªåŠ¨åŒæ­¥é—´éš”ï¼ˆåˆ†é’Ÿï¼‰</label>
                    <input type="number" id="webdavAutoSyncInterval" min="5" step="5" value="30" placeholder="30">
                </div>
                <div class="webdav-actions">
                    <button type="button" class="save-btn webdav-sync-btn" onclick="syncWebdavNow()">ç«‹å³åŒæ­¥</button>
                    <div class="webdav-status" id="webdavStatus">æœªåŒæ­¥</div>
                </div>
                <div class="webdav-help">
                    å°†åŒæ­¥èŠå¤©è®°å½• (chatSessions) ä¸ç»˜å›¾å†å² (imageGenHistory) åˆ° WebDAVã€‚
                </div>
                <div class="form-group" style="margin-top: 16px;">
                    <h4 style="margin: 0 0 8px 0; font-size: 0.95em; color: #555;">æœ¬åœ°å¯¼å…¥ / å¯¼å‡º</h4>
                    <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                        <button type="button" class="secondary-btn" onclick="exportLocalBackup()">å¯¼å‡ºå¤‡ä»½æ–‡ä»¶</button>
                        <button type="button" class="secondary-btn" onclick="document.getElementById('localBackupFile').click()">å¯¼å…¥å¤‡ä»½æ–‡ä»¶</button>
                        <input type="file" id="localBackupFile" accept="application/json" style="display:none" onchange="importLocalBackup(event)">
                    </div>
                    <p style="font-size: 0.8em; color: #888; margin-top: 6px;">ä¸ä½¿ç”¨ WebDAV æ—¶ï¼Œä¹Ÿå¯æ‰‹åŠ¨å¤‡ä»½æˆ–æ¢å¤æœ¬åœ°æ•°æ®ã€‚</p>
                </div>
            </div>

            <!-- æ‰©å±• -->
            <div id="settingsPanel-extension" class="settings-panel">
                <div style="text-align: center; padding: 40px 20px; color: #888;">
                    <div style="font-size: 3em; margin-bottom: 15px;">ğŸ§©</div>
                    <h3 style="margin: 0 0 10px 0; color: #666;">æ‰©å±•èƒ½åŠ›</h3>
                    <p style="margin: 0; font-size: 0.9em;">MCPï¼ˆModel Context Protocolï¼‰èƒ½åŠ›å¼€å‘ä¸­...</p>
                    <p style="margin: 10px 0 0 0; font-size: 0.85em;">åç»­ä¼šæä¾›å¤–éƒ¨å·¥å…·ä¸çŸ¥è¯†æºæ¥å…¥ã€‚</p>
                </div>
            </div>

            <button onclick="saveSettings()" class="save-btn">ä¿å­˜é…ç½®</button>
        </div>
    </div>


    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>
    <script src="utils.js?v=0.03"></script>
    <script>
        // ============ å®‰å…¨é…ç½® ============
        const SECURITY_CONFIG = {
            MAX_INPUT_LENGTH: 10000,      // æœ€å¤§è¾“å…¥é•¿åº¦
            MIN_SUBMIT_INTERVAL: 1000,    // æœ€å°æäº¤é—´éš”ï¼ˆæ¯«ç§’ï¼‰
            API_KEY_MIN_LENGTH: 20,       // API Key æœ€å°é•¿åº¦
            RATE_LIMIT_WINDOW: 60000,     // é€Ÿç‡é™åˆ¶çª—å£ï¼ˆ1åˆ†é’Ÿï¼‰
            RATE_LIMIT_MAX_REQUESTS: 30,  // çª—å£å†…æœ€å¤§è¯·æ±‚æ•°
        };

        // é€Ÿç‡é™åˆ¶è¿½è¸ª
        let requestTimestamps = [];
        let lastSubmitTime = 0;

        // å®‰å…¨åœ°ä½¿ç”¨å·¥å…·åº“ï¼ˆå¦‚æœåŠ è½½å¤±è´¥ä¹Ÿä¸å½±å“ä¸»åŠŸèƒ½ï¼‰
        const EchoUtils = window.EchoUtils || {};

        // ============ å®‰å…¨å‡½æ•° ============

        /**
         * ä½¿ç”¨ DOMPurify æ¸…ç† HTMLï¼Œé˜²æ­¢ XSS æ”»å‡»
         */
        function sanitizeHtml(html) {
            if (typeof DOMPurify !== 'undefined') {
                return DOMPurify.sanitize(html, {
                    ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'u', 's', 'code', 'pre', 'blockquote', 
                                   'ul', 'ol', 'li', 'a', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
                                   'table', 'thead', 'tbody', 'tr', 'th', 'td', 'hr', 'span', 'div'],
                    ALLOWED_ATTR: ['href', 'title', 'target', 'class', 'id'],
                    ALLOW_DATA_ATTR: false,
                    ADD_ATTR: ['target'], // å…è®¸æ·»åŠ  target å±æ€§
                    FORBID_TAGS: ['script', 'style', 'iframe', 'object', 'embed', 'form', 'input'],
                    FORBID_ATTR: ['onerror', 'onload', 'onclick', 'onmouseover', 'onfocus', 'onblur']
                });
            }
            // å¦‚æœ DOMPurify æœªåŠ è½½ï¼Œä½¿ç”¨åŸºæœ¬çš„è½¬ä¹‰
            return html
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
        }

        /**
         * å®‰å…¨åœ°æ¸²æŸ“ Markdown
         */
        function safeMarkdownRender(text) {
            const rawHtml = marked.parse(text);
            return sanitizeHtml(rawHtml);
        }

        /**
         * éªŒè¯è¾“å…¥å†…å®¹
         */
        function validateInput(text) {
            if (!text || typeof text !== 'string') {
                return { valid: false, error: 'è¾“å…¥å†…å®¹æ— æ•ˆ' };
            }
            
            const trimmed = text.trim();
            
            if (trimmed.length === 0) {
                return { valid: false, error: 'è¯·è¾“å…¥å†…å®¹' };
            }
            
            if (trimmed.length > SECURITY_CONFIG.MAX_INPUT_LENGTH) {
                return { valid: false, error: `è¾“å…¥å†…å®¹è¿‡é•¿ï¼Œæœ€å¤š ${SECURITY_CONFIG.MAX_INPUT_LENGTH} ä¸ªå­—ç¬¦` };
            }
            
            return { valid: true, text: trimmed };
        }

        /**
         * æ£€æŸ¥æäº¤é€Ÿç‡é™åˆ¶
         */
        function checkRateLimit() {
            const now = Date.now();
            
            // æ£€æŸ¥æœ€å°æäº¤é—´éš”
            if (now - lastSubmitTime < SECURITY_CONFIG.MIN_SUBMIT_INTERVAL) {
                return { allowed: false, error: 'è¯·ç¨åå†è¯•ï¼Œæ“ä½œè¿‡äºé¢‘ç¹' };
            }
            
            // æ¸…ç†è¿‡æœŸçš„æ—¶é—´æˆ³
            requestTimestamps = requestTimestamps.filter(
                ts => now - ts < SECURITY_CONFIG.RATE_LIMIT_WINDOW
            );
            
            // æ£€æŸ¥çª—å£å†…è¯·æ±‚æ•°
            if (requestTimestamps.length >= SECURITY_CONFIG.RATE_LIMIT_MAX_REQUESTS) {
                const waitTime = Math.ceil((SECURITY_CONFIG.RATE_LIMIT_WINDOW - (now - requestTimestamps[0])) / 1000);
                return { allowed: false, error: `è¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œè¯·ç­‰å¾… ${waitTime} ç§’åå†è¯•` };
            }
            
            return { allowed: true };
        }

        /**
         * è®°å½•è¯·æ±‚æ—¶é—´
         */
        function recordRequest() {
            const now = Date.now();
            lastSubmitTime = now;
            requestTimestamps.push(now);
        }

        /**
         * éªŒè¯ API Key æ ¼å¼
         */
        function validateApiKey(apiKey) {
            if (!apiKey || typeof apiKey !== 'string') {
                return { valid: false, error: 'API Key ä¸èƒ½ä¸ºç©º' };
            }
            
            const trimmed = apiKey.trim();
            
            if (trimmed.length < SECURITY_CONFIG.API_KEY_MIN_LENGTH) {
                return { valid: false, error: `API Key é•¿åº¦ä¸è¶³ï¼ˆè‡³å°‘ ${SECURITY_CONFIG.API_KEY_MIN_LENGTH} ä¸ªå­—ç¬¦ï¼‰` };
            }
            
            // æ£€æŸ¥æ˜¯å¦åŒ…å«å¯ç–‘å­—ç¬¦
            if (/[<>'"&]/.test(trimmed)) {
                return { valid: false, error: 'API Key åŒ…å«æ— æ•ˆå­—ç¬¦' };
            }
            
            return { valid: true, apiKey: trimmed };
        }

        /**
         * éªŒè¯ URL æ ¼å¼
         */
        function validateUrl(url) {
            if (!url || typeof url !== 'string') {
                return { valid: false, error: 'URL ä¸èƒ½ä¸ºç©º' };
            }
            
            try {
                const parsed = new URL(url.trim());
                // åªå…è®¸ http å’Œ https åè®®
                if (!['http:', 'https:'].includes(parsed.protocol)) {
                    return { valid: false, error: 'åªæ”¯æŒ HTTP/HTTPS åè®®' };
                }
                return { valid: true, url: parsed.href };
            } catch (e) {
                return { valid: false, error: 'URL æ ¼å¼æ— æ•ˆ' };
            }
        }

        /**
         * æ˜¾ç¤ºå®‰å…¨æç¤º
         */
        function showSecurityWarning(message) {
            console.warn('ğŸ”’ å®‰å…¨è­¦å‘Š:', message);
        }
        
        const chatMessages = document.getElementById('chatMessages');
        const userInput = document.getElementById('userInput');
        const sendBtn = document.getElementById('sendBtn');
        
        // å›¾ç‰‡ä¸Šä¼ ç›¸å…³
        let selectedImage = null;
        let selectedImageBase64 = null;
        const settingsModal = document.getElementById('settingsModal');
        const announcementModal = document.getElementById('announcementModal');
        const skillTrainingModal = document.getElementById('skillTrainingModal');
        const skillTrainingInput = document.getElementById('skillTrainingInput');
        const featureHistoryEls = {
            copywriting: document.getElementById('historyList-copywriting'),
            videoScript: document.getElementById('historyList-videoScript'),
            roleplay: document.getElementById('historyList-roleplay'),
            qaTest: document.getElementById('historyList-qaTest')
        };
        const FEATURE_META = {
            copywriting: { label: 'æ–‡æ¡ˆç”Ÿæˆ', icon: 'âœï¸', systemPrompt: 'ä½ æ˜¯ä¸€åèµ„æ·±æ–‡æ¡ˆç­–åˆ’ï¼Œè¯·æ ¹æ®ç”¨æˆ·éœ€æ±‚è¾“å‡ºå¸å¼•äººçš„æ–‡æ¡ˆï¼Œå¹¶ç»™å‡ºå¯é€‰ç‰ˆæœ¬ã€‚' },
            videoScript: { label: 'è§†é¢‘è„šæœ¬ä¼˜åŒ–', icon: 'ğŸ¬', systemPrompt: 'ä½ æ˜¯ä¸€åçŸ­è§†é¢‘ç¼–å¯¼ï¼Œè¯·ä¼˜åŒ–ç”¨æˆ·è„šæœ¬ï¼Œæå‡èŠ‚å¥ã€é•œå¤´æ„Ÿå’Œè½¬åŒ–æ•ˆæœã€‚' },
            roleplay: { label: 'è§’è‰²æ‰®æ¼”', icon: 'ğŸ­', systemPrompt: 'ä½ ç°åœ¨è¿›å…¥è§’è‰²æ‰®æ¼”æ¨¡å¼ï¼Œæ ¹æ®ç”¨æˆ·æŒ‡å®šè§’è‰²è¿›è¡Œè‡ªç„¶å¯¹è¯ï¼Œå¹¶ä¿æŒè§’è‰²ä¸€è‡´æ€§ã€‚' },
            qaTest: { label: 'æŠ€èƒ½è®­ç»ƒ', icon: 'ğŸ§ ', systemPrompt: 'ä½ æ˜¯ä¸€åæŠ€èƒ½è®­ç»ƒæ•™ç»ƒï¼Œè¯·å›´ç»•ç”¨æˆ·æŒ‡å®šæŠ€èƒ½ï¼Œäº¤æ›¿ç”Ÿæˆé€‰æ‹©é¢˜å’Œå¡«ç©ºé¢˜ï¼Œå¹¶æŒ‰è¡¨ç°è¯„ä¼°æŒæ¡åº¦ã€‚' }
        };
        
        const apiKeyInput = document.getElementById('apiKey');
        const modelNameInput = document.getElementById('modelName');
        
        // New Settings Inputs
        const tempRange = document.getElementById('tempRange');
        const contextRange = document.getElementById('contextRange');
        const streamToggle = document.getElementById('streamToggle');
        const maxTokensToggle = document.getElementById('maxTokensToggle');
        const maxTokensInput = document.getElementById('maxTokensInput');
        const webdavUrlInput = document.getElementById('webdavUrl');
        const webdavUsernameInput = document.getElementById('webdavUsername');
        const webdavPasswordInput = document.getElementById('webdavPassword');
        const webdavPathInput = document.getElementById('webdavPath');
        const webdavStatus = document.getElementById('webdavStatus');
        const webdavAutoSyncToggle = document.getElementById('webdavAutoSyncToggle');
        const webdavAutoSyncIntervalInput = document.getElementById('webdavAutoSyncInterval');
        const apiConnectionStatus = document.getElementById('apiConnectionStatus');
        const profileNameInput = document.getElementById('profileNameInput');
        const profileSelect = document.getElementById('profileSelect');

        // é»˜è®¤é…ç½®ï¼ˆä¸åŒ…å«æ•æ„Ÿä¿¡æ¯ï¼‰
        const DEFAULT_CONFIG = {
            apiUrl: 'https://ai.shuaihong.fun/v1/chat/completions',
            apiKey: '',  // ç”¨æˆ·éœ€è¦è‡ªè¡Œé…ç½®
            model: 'deepseek-v3.2',
            temperature: 0.7,
            contextLimit: 10,
            stream: true,
            enableMaxTokens: false,
            maxTokens: 2048
        };

        // æ•°æ®ç»“æ„ï¼šsessions = { sessionId: { id, title, messages: [] }, ... }
        // å½“å‰ä¼šè¯ ID
        let currentSessionId = null;
        let sessions = {};
        let isRequestInFlight = false;
        let skillTrainingAwaiting = false;
        let webdavAutoSyncTimer = null;

        const MODEL_PRESETS = {
            creative: { temperature: 1.1, contextLimit: 14, titleRegenInterval: 4, stream: true },
            rigorous: { temperature: 0.2, contextLimit: 8, titleRegenInterval: 6, stream: true }
        };

        // åˆå§‹åŒ–
        window.onload = function() {
            // 1. åŠ è½½é…ç½®
            const config = getSettings();
            apiKeyInput.value = config.apiKey || DEFAULT_CONFIG.apiKey;
            modelNameInput.value = config.model || DEFAULT_CONFIG.model;
            
            // åŠ è½½æ–°è®¾ç½®
            tempRange.value = config.temperature !== undefined ? config.temperature : DEFAULT_CONFIG.temperature;
            document.getElementById('tempValue').textContent = tempRange.value;
            
            contextRange.value = config.contextLimit !== undefined ? config.contextLimit : DEFAULT_CONFIG.contextLimit;
            document.getElementById('contextValue').textContent = contextRange.value;
            
            streamToggle.checked = config.stream !== undefined ? config.stream : DEFAULT_CONFIG.stream;
            
            maxTokensToggle.checked = config.enableMaxTokens !== undefined ? config.enableMaxTokens : DEFAULT_CONFIG.enableMaxTokens;
            maxTokensInput.value = config.maxTokens || DEFAULT_CONFIG.maxTokens;
            maxTokensInput.style.display = maxTokensToggle.checked ? 'block' : 'none';
            
            // åŠ è½½æ ‡é¢˜é‡ç”Ÿæˆé—´éš”è®¾ç½®
            const titleRegenRange = document.getElementById('titleRegenRange');
            titleRegenRange.value = config.titleRegenInterval !== undefined ? config.titleRegenInterval : 5;
            document.getElementById('titleRegenValue').textContent = titleRegenRange.value;
            
            // åŠ è½½è‡ªåŠ¨åˆ é™¤æ—§æ¶ˆæ¯è®¾ç½®
            document.getElementById('autoDeleteOldestToggle').checked = config.autoDeleteOldest || false;

            // åŠ è½½ WebDAV é…ç½®
            const webdavConfig = getWebdavConfig();
            webdavUrlInput.value = webdavConfig.url || '';
            webdavUsernameInput.value = webdavConfig.username || '';
            webdavPasswordInput.value = webdavConfig.password || '';
            webdavPathInput.value = webdavConfig.path || '';
            webdavAutoSyncToggle.checked = !!webdavConfig.autoSync;
            webdavAutoSyncIntervalInput.value = webdavConfig.autoSyncInterval || 30;
            if (webdavConfig.lastSync) {
                setWebdavStatus(`å·²åŒæ­¥ï¼š${webdavConfig.lastSync}`, 'success');
            } else {
                setWebdavStatus('æœªåŒæ­¥', 'info');
            }

            renderModelProfiles();
            scheduleWebdavAutoSync();

            // æ¢å¤ä¾§è¾¹æ çŠ¶æ€
            const isMobile = window.innerWidth <= 768;
            const savedState = localStorage.getItem('sidebarCollapsed');
            
            // å¦‚æœæ˜¯ç§»åŠ¨ç«¯ï¼Œé»˜è®¤æ”¶èµ·ï¼›æˆ–è€…è¯»å–å·²ä¿å­˜çš„çŠ¶æ€
            if (isMobile) {
                document.querySelector('.sidebar').classList.add('collapsed');
            } else if (savedState === 'true') {
                document.querySelector('.sidebar').classList.add('collapsed');
            }

            // 2. åˆå§‹åŒ–é¡¶éƒ¨æ¨¡å‹é€‰æ‹©å™¨
            initHeaderModelSelect();

            // 3. åŠ è½½å†å²ä¼šè¯
            loadSessions();
            restoreFeatureSectionState();

            // 4. å¦‚æœæ²¡æœ‰å†å²ä¼šè¯ï¼Œæ–°å»ºä¸€ä¸ªï¼›å¦åˆ™é»˜è®¤ä¸åŠ è½½ä»»ä½•å…·ä½“ä¼šè¯ï¼ˆæˆ–è€…åŠ è½½æœ€æ–°çš„ï¼‰
            if (Object.keys(sessions).length === 0) {
                startNewChat();
            } else {
                // é»˜è®¤åŠ è½½æœ€è¿‘çš„ä¸€ä¸ªä¼šè¯
                const sortedIds = Object.keys(sessions).sort((a, b) => sessions[b].timestamp - sessions[a].timestamp);
                switchChat(sortedIds[0]);
            }
        };

        function getSettings() {
            const stored = JSON.parse(localStorage.getItem('chatConfig')) || {};
            return { ...stored, apiUrl: DEFAULT_CONFIG.apiUrl };
        }

        function getWebdavConfig() {
            const stored = JSON.parse(localStorage.getItem('webdavConfig')) || {};
            return {
                url: stored.url || '',
                username: stored.username || '',
                password: stored.password || '',
                path: stored.path || '',
                lastSync: stored.lastSync || '',
                autoSync: stored.autoSync || false,
                autoSyncInterval: stored.autoSyncInterval || 30
            };
        }

        function saveWebdavConfig(config) {
            localStorage.setItem('webdavConfig', JSON.stringify(config));
        }

        function setWebdavStatus(message, type = 'info') {
            if (!webdavStatus) return;
            webdavStatus.textContent = message;
            webdavStatus.dataset.status = type;
        }

        function toggleSidebar() {
            const sidebar = document.querySelector('.sidebar');
            const overlay = document.querySelector('.sidebar-overlay');
            const isCollapsed = sidebar.classList.toggle('collapsed');
            
            // ç§»åŠ¨ç«¯å¤„ç†é®ç½©å±‚
            if (window.innerWidth <= 768) {
                if (isCollapsed) {
                    overlay.classList.remove('active');
                    // ç­‰å¾…è¿‡æ¸¡åŠ¨ç”»ç»“æŸåéšè—
                    setTimeout(() => {
                        if (!overlay.classList.contains('active')) overlay.style.display = 'none';
                    }, 300);
                } else {
                    overlay.style.display = 'block';
                    // å¼ºåˆ¶é‡ç»˜ä»¥è§¦å‘ transition
                    overlay.offsetHeight; 
                    overlay.classList.add('active');
                }
            }

            // åªæœ‰åœ¨éç§»åŠ¨ç«¯æ‰ä¿å­˜çŠ¶æ€ï¼Œé¿å…ç§»åŠ¨ç«¯çš„æ“ä½œå½±å“æ¡Œé¢ç«¯ä¹ æƒ¯
            if (window.innerWidth > 768) {
                localStorage.setItem('sidebarCollapsed', isCollapsed);
            }
        }

        // --- ä¼šè¯ç®¡ç†é€»è¾‘ ---

        function loadSessions() {
            const stored = localStorage.getItem('chatSessions');
            sessions = stored ? JSON.parse(stored) : {};

            Object.values(sessions).forEach(session => {
                if (!session.featureType || !FEATURE_META[session.featureType]) {
                    session.featureType = 'copywriting';
                }
                ensureRoleplayConfig(session);
                if (session.featureType === 'qaTest' && !session.quizState) {
                    session.quizState = {
                        mode: 'skillTraining',
                        status: 'setup',
                        skill: '',
                        answeredCount: 0,
                        score: 0,
                        recentQuestions: [],
                        reinforcementQueue: [],
                        history: [],
                        currentQuestion: null
                    };
                }
            });

            renderHistoryList();
        }

        function saveSessionsToStorage() {
            localStorage.setItem('chatSessions', JSON.stringify(sessions));
            renderHistoryList();
        }

        function generateId() {
            return Date.now().toString();
        }

        function startNewChat() {
            startFeatureChat('copywriting');
        }

        function startFeatureChat(featureType) {
            const feature = FEATURE_META[featureType] || FEATURE_META.copywriting;
            currentSessionId = generateId();
            sessions[currentSessionId] = {
                id: currentSessionId,
                title: `æ–°${feature.label}`,
                timestamp: Date.now(),
                featureType,
                systemPrompt: feature.systemPrompt,
                messages: [],
                quizState: featureType === 'qaTest' ? {
                    mode: 'skillTraining',
                    status: 'setup',
                    skill: '',
                    answeredCount: 0,
                    score: 0,
                    recentQuestions: [],
                    reinforcementQueue: [],
                    history: [],
                    currentQuestion: null
                } : null
            };
            
            // æ¸…ç©ºç•Œé¢
            chatMessages.innerHTML = `
                <div class="message-container ai">
                    <div class="avatar ai">AI</div>
                    <div class="message-content">${featureType === 'qaTest' ? 'å·²è¿›å…¥ğŸ§  æŠ€èƒ½è®­ç»ƒï¼Œè¯·å…ˆè®¾ç½®ä½ æƒ³å­¦ä¹ çš„æŠ€èƒ½ã€‚' : `å·²è¿›å…¥${feature.icon} ${feature.label}ï¼Œè¯·å‘Šè¯‰æˆ‘ä½ çš„å…·ä½“éœ€æ±‚ã€‚`}</div>
                </div>
            `;
            
            saveSessionsToStorage();
            switchChat(currentSessionId, false);

            if (featureType === 'qaTest') {
                openSkillTrainingModal();
            }
        }

        function startImageChat() {
            // 1. åˆ›å»ºæ–°ä¼šè¯
            currentSessionId = generateId();
            sessions[currentSessionId] = {
                id: currentSessionId,
                title: "ğŸ¨ ç»˜å›¾å¯¹è¯",
                timestamp: Date.now(),
                featureType: 'copywriting',
                isImageChat: true,
                messages: [],
                systemPrompt: "ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„ AI ç»˜å›¾åŠ©æ‰‹ã€‚å½“ç”¨æˆ·æè¿°ç”»é¢æ—¶ï¼Œè¯·è°ƒç”¨ç»˜å›¾èƒ½åŠ›ç”Ÿæˆå›¾ç‰‡ã€‚å¦‚æœç”¨æˆ·ä¸Šä¼ äº†å›¾ç‰‡ï¼Œè¯·æ ¹æ®ç”¨æˆ·çš„è¦æ±‚è¿›è¡Œä»¥å›¾ç”Ÿå›¾æˆ–å›¾ç‰‡åˆ†æã€‚"
            };

            // 2. åˆ‡æ¢æ¨¡å‹åˆ°ç»˜å›¾æ¨¡å‹
            const config = getSettings();
            // é»˜è®¤ç»˜å›¾æ¨¡å‹ï¼Œä¹Ÿå¯ä»¥è®¾ä¸ºé…ç½®é¡¹
            const imageModel = "gemini-3-pro-image-preview"; 
            config.model = imageModel;
            localStorage.setItem('chatConfig', JSON.stringify(config));

            // æ›´æ–° UI
            document.getElementById('modelName').value = imageModel;
            refreshHeaderModelSelect();

            // 3. åˆå§‹åŒ–ç•Œé¢
            chatMessages.innerHTML = `
                <div class="message-container ai">
                    <div class="avatar ai">AI</div>
                    <div class="message-content">å·²åˆ‡æ¢åˆ°ç»˜å›¾æ¨¡å¼ (å½“å‰æ¨¡å‹: ${imageModel})ã€‚<br>è¯·æè¿°ä½ æƒ³ç”Ÿæˆçš„å›¾ç‰‡ï¼Œæˆ–è€…ä¸Šä¼ å›¾ç‰‡è¿›è¡Œå‚è€ƒã€‚</div>
                </div>
            `;

            saveSessionsToStorage();
            switchChat(currentSessionId, false);
            
            // è‡ªåŠ¨æ”¶èµ·ä¾§è¾¹æ  (ç§»åŠ¨ç«¯)
            if (window.innerWidth <= 768) {
                toggleSidebar();
            }
        }

        function startQuickDrawChat() {
            closeImageGenerator();
            startImageChat();
        }

        function openDrawingHub() {
            openImageGenerator();
        }

        function switchChat(sessionId, render = true) {
            if (!sessions[sessionId]) return;
            currentSessionId = sessionId;
            
            // ç§»åŠ¨ç«¯åˆ‡æ¢ä¼šè¯åè‡ªåŠ¨æ”¶èµ·ä¾§è¾¹æ 
            if (window.innerWidth <= 768 && !document.querySelector('.sidebar').classList.contains('collapsed')) {
                toggleSidebar();
            }

            // æ›´æ–° UI é«˜äº®
            renderHistoryList();
            updateHeaderInfo();
            renderSkillTrainingDashboard(sessions[sessionId].quizState);
            refreshHeaderModelSelect();

            if (render) {
                chatMessages.innerHTML = '';
                const msgs = sessions[sessionId].messages;
                if (msgs.length === 0) {
                    chatMessages.innerHTML = `
                        <div class="message-container ai">
                            <div class="avatar ai">AI</div>
                            <div class="content-wrapper">
                                <div class="message-content">ä½ å¥½ï¼ä»Šå¤©æœ‰ä»€ä¹ˆæˆ‘å¯ä»¥å¸®ä½ çš„å—ï¼Ÿ</div>
                            </div>
                        </div>
                    `;
                } else {
                    msgs.forEach((msg, index) => {
                        appendMessageToUI(msg.content, msg.role === 'user' ? 'user' : 'ai', false, index);
                    });
                }
            }
        }

        function deleteChat(event, sessionId) {
            event.stopPropagation(); // é˜²æ­¢è§¦å‘ç‚¹å‡»åˆ‡æ¢
            if (confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡å¯¹è¯å—ï¼Ÿ')) {
                delete sessions[sessionId];
                saveSessionsToStorage();
                
                // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰ä¼šè¯ï¼Œé‡ç½®
                if (sessionId === currentSessionId) {
                    const remainingIds = Object.keys(sessions);
                    if (remainingIds.length > 0) {
                        switchChat(remainingIds[0]);
                    } else {
                        startNewChat();
                    }
                }
            }
        }

        function renderHistoryList() {
            Object.values(featureHistoryEls).forEach(el => {
                if (el) el.innerHTML = '';
            });

            // æŒ‰æ—¶é—´å€’åº
            const sortedIds = Object.keys(sessions).sort((a, b) => sessions[b].timestamp - sessions[a].timestamp);
            
            sortedIds.forEach(id => {
                const session = sessions[id];
                const featureType = session.featureType && FEATURE_META[session.featureType] ? session.featureType : 'copywriting';
                const targetList = featureHistoryEls[featureType];
                if (!targetList) return;

                const div = document.createElement('div');
                div.className = `history-item ${id === currentSessionId ? 'active' : ''}`;
                div.onclick = () => switchChat(id);
                const icon = FEATURE_META[featureType].icon;
                
                div.innerHTML = `
                    <span style="overflow: hidden; text-overflow: ellipsis; flex: 1;">${icon} ${session.title}</span>
                    <div class="actions">
                        <button class="action-btn" onclick="regenerateTitle(event, '${id}')" title="AI é‡æ–°ç”Ÿæˆæ ‡é¢˜">âœ</button>
                        <button class="action-btn" onclick="deleteChat(event, '${id}')" title="åˆ é™¤å¯¹è¯">Ã—</button>
                    </div>
                `;
                targetList.appendChild(div);
            });
        }

        function toggleFeatureSection(featureType) {
            const section = document.querySelector(`.feature-section[data-feature="${featureType}"]`);
            if (!section) return;

            const isCollapsed = section.classList.toggle('collapsed');
            localStorage.setItem(`featureSectionCollapsed_${featureType}`, isCollapsed ? '1' : '0');
        }

        function restoreFeatureSectionState() {
            Object.keys(FEATURE_META).forEach(featureType => {
                const section = document.querySelector(`.feature-section[data-feature="${featureType}"]`);
                if (!section) return;
                const isCollapsed = localStorage.getItem(`featureSectionCollapsed_${featureType}`) === '1';
                section.classList.toggle('collapsed', isCollapsed);
            });
        }

        function updateHeaderInfo() {
            const hintEl = document.getElementById('systemPromptHint');
            
            if (!currentSessionId || !sessions[currentSessionId]) {
                document.getElementById('currentTopicTitle').textContent = 'æ–°å¯¹è¯';
                document.getElementById('contextInfo').textContent = 'ğŸ“ ä¸Šä¸‹æ–‡: 0 æ¡';
                document.getElementById('tokenInfo').textContent = 'ğŸ”¤ é¢„ä¼°: ~0 tokens';
                hintEl.textContent = 'âœ¨ ç‚¹å‡»è®¾ç½®åŠ©æ‰‹è§’è‰²';
                renderSkillTrainingDashboard(null);
                return;
            }
            
            const session = sessions[currentSessionId];
            
            // æ›´æ–°æ ‡é¢˜
            document.getElementById('currentTopicTitle').textContent = session.title || 'æ–°å¯¹è¯';
            
            // æ›´æ–°ä¸Šä¸‹æ–‡æ¡æ•°
            document.getElementById('contextInfo').textContent = `ğŸ“ ä¸Šä¸‹æ–‡: ${session.messages.length} æ¡`;
            
            // ä¼°ç®— Token æ•° (ç²—ç•¥ä¼°è®¡: ä¸­æ–‡çº¦1.5å­—ç¬¦/token, è‹±æ–‡çº¦4å­—ç¬¦/token, å–ä¸­é—´å€¼çº¦2.5)
            const charCount = session.messages.reduce((sum, m) => sum + m.content.length, 0);
            const estimatedTokens = Math.round(charCount / 2.5);
            document.getElementById('tokenInfo').textContent = `ğŸ”¤ é¢„ä¼°: ~${estimatedTokens} tokens`;
            
            // æ›´æ–°ç³»ç»Ÿæç¤ºè¯æ˜¾ç¤º
            if (session.systemPrompt) {
                const truncated = session.systemPrompt.length > 30 
                    ? session.systemPrompt.substring(0, 30) + '...' 
                    : session.systemPrompt;
                hintEl.textContent = `ğŸ­ ${truncated}`;
                hintEl.title = session.systemPrompt;
            } else {
                hintEl.textContent = 'âœ¨ ç‚¹å‡»è®¾ç½®åŠ©æ‰‹è§’è‰²';
                hintEl.title = 'ç‚¹å‡»ç¼–è¾‘ç³»ç»Ÿæç¤ºè¯';
            }

            renderSkillTrainingDashboard(session.quizState);
        }

        // ============ å†…ç½®è§’è‰²å¡ ============
        const PRESET_ROLES = [
            {
                id: 'general',
                name: 'ğŸ¤– é€šç”¨åŠ©æ‰‹',
                icon: 'ğŸ¤–',
                description: 'å‹å–„çš„ AI åŠ©æ‰‹ï¼Œå¸®åŠ©å›ç­”å„ç§é—®é¢˜',
                prompt: 'ä½ æ˜¯ä¸€ä¸ªå‹å–„ã€ä¸“ä¸šçš„ AI åŠ©æ‰‹ã€‚ä½ ä¼šç”¨ç®€æ´æ¸…æ™°çš„è¯­è¨€å›ç­”ç”¨æˆ·çš„é—®é¢˜ï¼Œå¿…è¦æ—¶ä¼šæä¾›è¯¦ç»†çš„è§£é‡Šå’Œç¤ºä¾‹ã€‚'
            },
            {
                id: 'programmer',
                name: 'ğŸ’» ç¼–ç¨‹ä¸“å®¶',
                icon: 'ğŸ’»',
                description: 'ç²¾é€šå¤šç§ç¼–ç¨‹è¯­è¨€çš„å¼€å‘è€…',
                prompt: 'ä½ æ˜¯ä¸€ä½èµ„æ·±çš„å…¨æ ˆå¼€å‘å·¥ç¨‹å¸ˆï¼Œç²¾é€š Pythonã€JavaScriptã€Javaã€Goã€Rust ç­‰å¤šç§ç¼–ç¨‹è¯­è¨€ã€‚ä½ æ“…é•¿ä»£ç å®¡æŸ¥ã€æ¶æ„è®¾è®¡ã€æ€§èƒ½ä¼˜åŒ–å’Œ Debugã€‚å›ç­”é—®é¢˜æ—¶ä¼šæä¾›æ¸…æ™°çš„ä»£ç ç¤ºä¾‹å’Œæœ€ä½³å®è·µå»ºè®®ã€‚'
            },
            {
                id: 'translator',
                name: 'ğŸŒ ç¿»è¯‘ä¸“å®¶',
                icon: 'ğŸŒ',
                description: 'ç²¾é€šä¸­è‹±æ—¥éŸ©å¤šè¯­è¨€ç¿»è¯‘',
                prompt: 'ä½ æ˜¯ä¸€ä½ä¸“ä¸šçš„å¤šè¯­è¨€ç¿»è¯‘ä¸“å®¶ï¼Œç²¾é€šä¸­æ–‡ã€è‹±è¯­ã€æ—¥è¯­ã€éŸ©è¯­ç­‰å¤šç§è¯­è¨€ã€‚ä½ ä¼šæä¾›å‡†ç¡®ã€åœ°é“çš„ç¿»è¯‘ï¼Œå¹¶åœ¨å¿…è¦æ—¶è§£é‡Šæ–‡åŒ–å·®å¼‚å’Œè¯­è¨€ä¹ æƒ¯ã€‚'
            },
            {
                id: 'writer',
                name: 'âœï¸ å†™ä½œåŠ©æ‰‹',
                icon: 'âœï¸',
                description: 'å¸®åŠ©åˆ›ä½œå„ç±»æ–‡æ¡ˆå’Œå†…å®¹',
                prompt: 'ä½ æ˜¯ä¸€ä½åˆ›æ„å†™ä½œä¸“å®¶ï¼Œæ“…é•¿æ’°å†™å„ç±»æ–‡æ¡ˆã€æ–‡ç« ã€æ•…äº‹å’Œè¥é”€å†…å®¹ã€‚ä½ çš„å†™ä½œé£æ ¼ç”ŸåŠ¨æœ‰è¶£ï¼Œèƒ½æ ¹æ®ä¸åŒåœºæ™¯è°ƒæ•´è¯­æ°”å’Œé£æ ¼ã€‚ä½ ä¹Ÿæ“…é•¿æ¶¦è‰²å’Œæ”¹è¿›ç°æœ‰æ–‡æœ¬ã€‚'
            },
            {
                id: 'teacher',
                name: 'ğŸ“š å­¦ä¹ å¯¼å¸ˆ',
                icon: 'ğŸ“š',
                description: 'è€å¿ƒçš„è€å¸ˆï¼Œå–„äºè§£é‡Šå¤æ‚æ¦‚å¿µ',
                prompt: 'ä½ æ˜¯ä¸€ä½è€å¿ƒã€å–„äºè§£é‡Šçš„è€å¸ˆã€‚ä½ ä¼šç”¨é€šä¿—æ˜“æ‡‚çš„è¯­è¨€è§£é‡Šå¤æ‚çš„æ¦‚å¿µï¼Œå–„äºä½¿ç”¨æ¯”å–»å’Œå®ä¾‹å¸®åŠ©ç†è§£ã€‚ä½ ä¼šæ ¹æ®å­¦ç”Ÿçš„æ°´å¹³è°ƒæ•´è®²è§£æ–¹å¼ï¼Œå¹¶æä¾›ç»ƒä¹ å»ºè®®ã€‚'
            },
            {
                id: 'analyst',
                name: 'ğŸ“Š æ•°æ®åˆ†æå¸ˆ',
                icon: 'ğŸ“Š',
                description: 'ä¸“ä¸šçš„æ•°æ®åˆ†æå’Œå¯è§†åŒ–ä¸“å®¶',
                prompt: 'ä½ æ˜¯ä¸€ä½èµ„æ·±æ•°æ®åˆ†æå¸ˆï¼Œç²¾é€šæ•°æ®å¤„ç†ã€ç»Ÿè®¡åˆ†æå’Œæ•°æ®å¯è§†åŒ–ã€‚ä½ ç†Ÿç»ƒä½¿ç”¨ Pythonã€SQLã€Excel ç­‰å·¥å…·ï¼Œèƒ½å¤Ÿä»æ•°æ®ä¸­æå–æ´å¯Ÿï¼Œå¹¶ç»™å‡ºå¯è¡Œçš„ä¸šåŠ¡å»ºè®®ã€‚'
            },
            {
                id: 'marketer',
                name: 'ğŸ“¢ è¥é”€ç­–åˆ’',
                icon: 'ğŸ“¢',
                description: 'åˆ›æ„è¥é”€å’Œå“ç‰Œæ¨å¹¿ä¸“å®¶',
                prompt: 'ä½ æ˜¯ä¸€ä½ç»éªŒä¸°å¯Œçš„è¥é”€ç­–åˆ’ä¸“å®¶ï¼Œç²¾é€šå“ç‰Œå®šä½ã€å†…å®¹è¥é”€ã€ç¤¾äº¤åª’ä½“è¿è¥å’Œå¢é•¿ç­–ç•¥ã€‚ä½ èƒ½å¤Ÿæ ¹æ®äº§å“ç‰¹ç‚¹å’Œç›®æ ‡å—ä¼—ï¼Œåˆ¶å®šæœ‰æ•ˆçš„è¥é”€æ–¹æ¡ˆã€‚'
            },
            {
                id: 'lawyer',
                name: 'âš–ï¸ æ³•å¾‹é¡¾é—®',
                icon: 'âš–ï¸',
                description: 'æä¾›æ³•å¾‹å’¨è¯¢å’Œå»ºè®®',
                prompt: 'ä½ æ˜¯ä¸€ä½ä¸“ä¸šçš„æ³•å¾‹é¡¾é—®ï¼Œç†Ÿæ‚‰ä¸­å›½æ³•å¾‹æ³•è§„ã€‚ä½ ä¼šç”¨é€šä¿—æ˜“æ‡‚çš„è¯­è¨€è§£é‡Šæ³•å¾‹æ¦‚å¿µï¼Œåˆ†ææ¡ˆä¾‹ï¼Œå¹¶æä¾›åˆè§„å»ºè®®ã€‚ä½†ä½ ä¼šæé†’ç”¨æˆ·ï¼Œæ­£å¼æ³•å¾‹äº‹åŠ¡éœ€è¦å’¨è¯¢ä¸“ä¸šå¾‹å¸ˆã€‚'
            },
            {
                id: 'psychologist',
                name: 'ğŸ’¬ å¿ƒç†å’¨è¯¢å¸ˆ',
                icon: 'ğŸ’¬',
                description: 'æ¸©æš–çš„å€¾å¬è€…ï¼Œæä¾›æƒ…æ„Ÿæ”¯æŒ',
                prompt: 'ä½ æ˜¯ä¸€ä½æ¸©æš–ã€æœ‰åŒç†å¿ƒçš„å¿ƒç†å’¨è¯¢å¸ˆã€‚ä½ ä¼šè€å¿ƒå€¾å¬ï¼Œæä¾›æƒ…æ„Ÿæ”¯æŒå’Œå»ºè®¾æ€§çš„å»ºè®®ã€‚ä½ ä½¿ç”¨ç§¯æå¿ƒç†å­¦çš„æ–¹æ³•å¸®åŠ©ç”¨æˆ·ã€‚ä½†ä½ ä¼šæé†’ç”¨æˆ·ï¼Œä¸¥é‡çš„å¿ƒç†é—®é¢˜éœ€è¦å¯»æ±‚ä¸“ä¸šå¸®åŠ©ã€‚'
            },
            {
                id: 'chef',
                name: 'ğŸ³ ç¾é£Ÿä¸“å®¶',
                icon: 'ğŸ³',
                description: 'ä¸­è¥¿é¤çƒ¹é¥ªå’Œè¥å…»æ­é…ä¸“å®¶',
                prompt: 'ä½ æ˜¯ä¸€ä½ç¾é£Ÿä¸“å®¶ï¼Œç²¾é€šä¸­è¥¿é¤çƒ¹é¥ªæŠ€å·§å’Œè¥å…»æ­é…ã€‚ä½ èƒ½æ¨èé£Ÿè°±ã€è§£ç­”çƒ¹é¥ªé—®é¢˜ã€æä¾›é£Ÿææ›¿ä»£å»ºè®®ï¼Œå¹¶è€ƒè™‘å¥åº·é¥®é£Ÿçš„éœ€æ±‚ã€‚'
            },
            {
                id: 'fitness',
                name: 'ğŸ’ª å¥èº«æ•™ç»ƒ',
                icon: 'ğŸ’ª',
                description: 'ä¸“ä¸šå¥èº«æŒ‡å¯¼å’Œè®­ç»ƒè®¡åˆ’',
                prompt: 'ä½ æ˜¯ä¸€ä½ä¸“ä¸šçš„å¥èº«æ•™ç»ƒï¼Œç²¾é€šåŠ›é‡è®­ç»ƒã€æœ‰æ°§è¿åŠ¨å’Œä½“æ€çŸ«æ­£ã€‚ä½ ä¼šæ ¹æ®ç”¨æˆ·çš„èº«ä½“çŠ¶å†µå’Œç›®æ ‡ï¼Œæä¾›ä¸ªæ€§åŒ–çš„è®­ç»ƒè®¡åˆ’å’ŒåŠ¨ä½œæŒ‡å¯¼ï¼ŒåŒæ—¶æ³¨æ„å®‰å…¨æé†’ã€‚'
            },
            {
                id: 'custom',
                name: 'âœ¨ è‡ªå®šä¹‰è§’è‰²',
                icon: 'âœ¨',
                description: 'è¾“å…¥è‡ªå®šä¹‰çš„è§’è‰²è®¾å®š',
                prompt: ''
            }
        ];

        const BUILTIN_ROLEPLAY_PRESETS = [
            {
                id: 'mafia-boss',
                name: 'ğŸ•¶ï¸ é»‘å¸®æ•™çˆ¶',
                description: 'å¼ºåŠ¿ã€è®²è§„çŸ©ï¼Œé€‚åˆå‰§æƒ…å¯¹è¯',
                prompt: 'ä½ æ˜¯é»‘å¸®å®¶æ—çš„æ•™çˆ¶ï¼Œæ²‰ç¨³ã€å¨ä¸¥ã€è¯´è¯ç®€æ´ï¼Œé‡è§†åˆ©ç›Šä¸æ‰¿è¯ºã€‚',
                worldBook: [
                    { key: 'å®¶æ—', content: 'ç»´å…‹æ‰˜å®¶æ—æŒæ§æ¸¯å£ç‰©æµã€åœ°ä¸‹æƒ…æŠ¥ä¸ç°è‰²é‡‘èã€‚' },
                    { key: 'ç¦å¿Œ', content: 'ä¸¥ç¦èƒŒå›å®¶æ—ï¼Œä»»ä½•å›å¾’éƒ½å¿…é¡»æ¥å—å®¡åˆ¤ã€‚' }
                ],
                presets: [
                    { name: 'è°ˆåˆ¤æ¨¡å¼', content: 'ä¼˜å…ˆä»¥äº¤æ˜“å’Œç­¹ç æ¨åŠ¨å‰§æƒ…ï¼Œé¿å…æ— æ„ä¹‰å†²çªã€‚' },
                    { name: 'å‹è¿«æ„Ÿè¯­æ°”', content: 'æ¯æ¬¡å›å¤æ§åˆ¶åœ¨ 2-5 å¥ï¼Œä¿æŒå†·é™ä½†å‹è¿«æ„Ÿã€‚' }
                ]
            },
            {
                id: 'fantasy-mage',
                name: 'ğŸª„ å¹»æƒ³æ³•å¸ˆ',
                description: 'é«˜å¹»æƒ³è®¾å®šï¼Œé€‚åˆå†’é™©ä¸–ç•Œè§‚',
                prompt: 'ä½ æ˜¯å¥¥æœ¯å­¦é™¢é¦–å¸­æ³•å¸ˆï¼Œæ“…é•¿ç¬¦æ–‡ã€å¬å”¤ä¸å…ƒç´ é­”æ³•ã€‚',
                worldBook: [
                    { key: 'å¤§é™†', content: 'åŸƒå…°å¤§é™†åˆ†ä¸ºåŒ—å¢ƒã€ç¾¤æ˜Ÿå¸å›½ã€ç°çƒ¬è’åŸä¸‰å¤§åŠ¿åŠ›ã€‚' },
                    { key: 'æ³•åˆ™', content: 'é«˜é˜¶é­”æ³•ä¼šæ¶ˆè€—ç²¾ç¥åŠ›ï¼Œè¿‡åº¦æ–½æ³•å¯èƒ½å¯¼è‡´å¤±æ§ã€‚' }
                ],
                presets: [
                    { name: 'æ²‰æµ¸æå†™', content: 'ä½¿ç”¨ç¯å¢ƒæå†™å’ŒåŠ¨ä½œæå†™å¢å¼ºä»£å…¥æ„Ÿã€‚' }
                ]
            },
            {
                id: 'campus-sweet',
                name: 'ğŸ“ æ ¡å›­é’æ¢…',
                description: 'è½»æ¾æ—¥å¸¸é£æ ¼ï¼Œé€‚åˆé™ªä¼´èŠå¤©',
                prompt: 'ä½ æ˜¯ç”¨æˆ·çš„é’æ¢…ç«¹é©¬ï¼Œæ€§æ ¼æ¸©æŸ”å¼€æœ—ï¼Œç†Ÿæ‚‰æ ¡å›­ç”Ÿæ´»ç»†èŠ‚ã€‚',
                worldBook: [
                    { key: 'å­¦æ ¡', content: 'æ˜Ÿæ²³é«˜ä¸­ä»¥ç¤¾å›¢æ–‡åŒ–é—»åï¼Œæ¯å‘¨äº”æœ‰ç¤¾å›¢å¼€æ”¾æ—¥ã€‚' }
                ],
                presets: [
                    { name: 'è½»æ¾äº’åŠ¨', content: 'å¤šç”¨å£è¯­è¡¨è¾¾ï¼Œå‡å°‘è¯´æ•™å¼å›ç­”ã€‚' }
                ]
            },
            {
                id: 'sci-fi-ai',
                name: 'ğŸš€ æ˜Ÿèˆ° AI',
                description: 'ç§‘å¹»åŠ©æ‰‹ï¼Œé€‚åˆä»»åŠ¡æ¨è¿›',
                prompt: 'ä½ æ˜¯æ˜Ÿèˆ°â€œæ›™å…‰å·â€çš„èˆ°è½½ AIï¼Œè´Ÿè´£å¯¼èˆªã€æˆ˜æœ¯å’Œèˆ¹å‘˜æ”¯æŒã€‚',
                worldBook: [
                    { key: 'é£èˆ¹', content: 'æ›™å…‰å·æ‹¥æœ‰è·ƒè¿å¼•æ“ã€æ— äººæœºç¾¤å’Œå¤šå±‚é˜²æŠ¤æŠ¤ç›¾ã€‚' }
                ],
                presets: [
                    { name: 'ä»»åŠ¡ç®€æŠ¥', content: 'è¾“å‡ºä½¿ç”¨â€œç›®æ ‡/é£é™©/å»ºè®®è¡ŒåŠ¨â€ä¸‰æ®µæ ¼å¼ã€‚' }
                ]
            }
        ];

        function editSystemPrompt() {
            if (!currentSessionId || !sessions[currentSessionId]) return;
            openRoleSelector();
        }

        function ensureRoleplayConfig(session) {
            if (!session) return { worldBook: [], presets: [] };
            if (!session.roleplayConfig) {
                session.roleplayConfig = {
                    roleName: '',
                    roleDescription: '',
                    worldBook: [],
                    presets: []
                };
            }
            if (!Array.isArray(session.roleplayConfig.worldBook)) session.roleplayConfig.worldBook = [];
            if (!Array.isArray(session.roleplayConfig.presets)) session.roleplayConfig.presets = [];
            return session.roleplayConfig;
        }

        function buildEffectiveSystemPrompt(session) {
            if (!session) return '';
            const basePrompt = session.systemPrompt || '';
            const roleplayConfig = ensureRoleplayConfig(session);
            const sections = [];
            if (basePrompt) sections.push(basePrompt);
            if (roleplayConfig.worldBook.length > 0) {
                const wbText = roleplayConfig.worldBook
                    .map(item => `- ${item.key || 'æ¡ç›®'}: ${item.content || ''}`)
                    .join('\n');
                sections.push(`ã€ä¸–ç•Œä¹¦ã€‘
${wbText}`);
            }
            if (roleplayConfig.presets.length > 0) {
                const presetText = roleplayConfig.presets
                    .map(item => `- ${item.name || 'é¢„è®¾'}: ${item.content || ''}`)
                    .join('\n');
                sections.push(`ã€è¡Œä¸ºé¢„è®¾ã€‘
${presetText}`);
            }
            return sections.join('\n\n').trim();
        }

        function openRoleSelector() {
            let roleModal = document.getElementById('roleModal');
            if (!roleModal) {
                roleModal = document.createElement('div');
                roleModal.id = 'roleModal';
                roleModal.className = 'modal';
                roleModal.innerHTML = `
                    <div class="modal-content role-modal-content">
                        <div class="modal-header"><span>ğŸ­ è§’è‰²æ‰®æ¼”å·¥ä½œå°</span></div>
                        <div class="role-grid" id="roleGrid"></div>
                        <div class="custom-prompt-section" id="customPromptSection" style="display: none;">
                            <label>è§’è‰²è®¾å®šï¼ˆSystem Promptï¼‰</label>
                            <textarea id="customPromptInput" rows="4" placeholder="è¯·è¾“å…¥è§’è‰²è®¾å®š..."></textarea>
                            <label>è§’è‰²åï¼ˆå¯é€‰ï¼‰</label>
                            <input id="roleNameInput" type="text" placeholder="ä¾‹å¦‚ï¼šç»´å…‹æ‰˜æ•™çˆ¶" />
                            <label>è§’è‰²æè¿°ï¼ˆå¯é€‰ï¼‰</label>
                            <input id="roleDescriptionInput" type="text" placeholder="ä¾‹å¦‚ï¼šæŒæ§æ¸¯å£çš„å®¶æ—é¦–é¢†" />
                            <label>ä¸–ç•Œä¹¦ï¼ˆæ¯è¡Œï¼šå…³é”®è¯::å†…å®¹ï¼‰</label>
                            <textarea id="worldBookInput" rows="4" placeholder="å®¶æ—::ç»´å…‹æ‰˜å®¶æ—æŒæ§æ¸¯å£
ç¦å¿Œ::ä¸¥ç¦èƒŒå›"></textarea>
                            <label>è¡Œä¸ºé¢„è®¾ï¼ˆæ¯è¡Œï¼šåç§°::è§„åˆ™ï¼‰</label>
                            <textarea id="presetInput" rows="4" placeholder="è°ˆåˆ¤æ¨¡å¼::ä¼˜å…ˆäº¤æ˜“ä¸ç­¹ç 
å‹è¿«è¯­æ°”::æ¯æ¬¡å›å¤ 2-5 å¥"></textarea>
                        </div>
                        <div class="role-modal-actions">
                            <label class="import-btn" for="roleJsonImport">ğŸ“¥ å¯¼å…¥è§’è‰² JSON</label>
                            <input id="roleJsonImport" type="file" accept="application/json,.json" style="display:none;" onchange="importRoleJson(event)">
                            <button onclick="exportCurrentRoleJson()" class="save-btn save-btn-secondary">ğŸ“¤ å¯¼å‡ºå½“å‰è§’è‰²</button>
                            <button onclick="applyRole()" class="save-btn" id="applyRoleBtn">åº”ç”¨è§’è‰²</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(roleModal);

                roleModal.addEventListener('click', function(e) {
                    if (e.target === roleModal) closeRoleSelector();
                });
            }

            const roleGrid = document.getElementById('roleGrid');
            const session = sessions[currentSessionId];
            const roleplayConfig = ensureRoleplayConfig(session);
            const currentPrompt = session?.systemPrompt || '';

            roleGrid.innerHTML = '';
            [...BUILTIN_ROLEPLAY_PRESETS, ...PRESET_ROLES].forEach(role => {
                const card = document.createElement('div');
                card.className = 'role-card' + (role.id === 'custom' ? ' custom' : '');
                card.dataset.roleId = role.id;
                card.innerHTML = `<div class="role-icon">${role.icon || 'ğŸ­'}</div><div class="role-name">${role.name}</div><div class="role-desc">${role.description}</div>`;
                card.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    selectRole(role.id);
                });
                roleGrid.appendChild(card);
            });

            const matchedRole = PRESET_ROLES.find(r => r.prompt && r.prompt === currentPrompt);
            if (matchedRole) {
                selectRole(matchedRole.id);
            } else {
                selectRole('custom');
            }
            document.getElementById('customPromptInput').value = currentPrompt;
            document.getElementById('roleNameInput').value = roleplayConfig.roleName || '';
            document.getElementById('roleDescriptionInput').value = roleplayConfig.roleDescription || '';
            document.getElementById('worldBookInput').value = (roleplayConfig.worldBook || []).map(item => `${item.key || ''}::${item.content || ''}`).join('\n');
            document.getElementById('presetInput').value = (roleplayConfig.presets || []).map(item => `${item.name || ''}::${item.content || ''}`).join('\n');

            roleModal.style.display = 'flex';
        }

        let selectedRoleId = null;

        function parseMultiLinePairs(text, fallbackKey = 'æ¡ç›®') {
            return text
                .split('\n')
                .map(line => line.trim())
                .filter(Boolean)
                .map((line, index) => {
                    const parts = line.split('::');
                    if (parts.length >= 2) {
                        return { key: parts[0].trim() || `${fallbackKey}${index + 1}`, content: parts.slice(1).join('::').trim() };
                    }
                    return { key: `${fallbackKey}${index + 1}`, content: line };
                });
        }

        function selectRole(roleId) {
            selectedRoleId = roleId;
            document.querySelectorAll('.role-card').forEach(card => {
                card.classList.toggle('selected', card.dataset.roleId === roleId);
            });

            const customSection = document.getElementById('customPromptSection');
            customSection.style.display = 'block';

            const role = [...BUILTIN_ROLEPLAY_PRESETS, ...PRESET_ROLES].find(r => r.id === roleId);
            if (!role) return;

            if (role.id === 'custom') return;
            document.getElementById('customPromptInput').value = role.prompt || '';
            document.getElementById('roleNameInput').value = role.name || '';
            document.getElementById('roleDescriptionInput').value = role.description || '';
            document.getElementById('worldBookInput').value = (role.worldBook || []).map(item => `${item.key || ''}::${item.content || ''}`).join('\n');
            document.getElementById('presetInput').value = (role.presets || []).map(item => `${item.name || ''}::${item.content || ''}`).join('\n');
        }

        async function importRoleJson(event) {
            const file = event.target.files?.[0];
            if (!file) return;
            try {
                const text = await file.text();
                const data = JSON.parse(text);
                const cardData = data.data || data;
                const worldEntries = cardData.character_book?.entries || cardData.world_book?.entries || [];
                const worldBook = worldEntries.map((entry, index) => ({
                    key: (entry.keys && entry.keys[0]) || entry.comment || `ä¸–ç•Œä¹¦${index + 1}`,
                    content: entry.content || ''
                })).filter(item => item.content);

                document.getElementById('customPromptInput').value = cardData.system_prompt || cardData.description || data.description || '';
                document.getElementById('roleNameInput').value = cardData.name || data.name || '';
                document.getElementById('roleDescriptionInput').value = cardData.personality || cardData.first_mes || '';
                document.getElementById('worldBookInput').value = worldBook.map(item => `${item.key}::${item.content}`).join('\n');
                document.getElementById('presetInput').value = '';
                selectRole('custom');
                alert('è§’è‰² JSON å¯¼å…¥æˆåŠŸï¼Œè¯·ç¡®è®¤åç‚¹å‡»â€œåº”ç”¨è§’è‰²â€ã€‚');
            } catch (error) {
                alert(`å¯¼å…¥å¤±è´¥ï¼š${error.message}`);
            } finally {
                event.target.value = '';
            }
        }

        function exportCurrentRoleJson() {
            if (!currentSessionId || !sessions[currentSessionId]) return;
            const session = sessions[currentSessionId];
            const roleplayConfig = ensureRoleplayConfig(session);
            const payload = {
                spec: 'chara_card_v2',
                spec_version: '2.0',
                data: {
                    name: roleplayConfig.roleName || 'è‡ªå®šä¹‰è§’è‰²',
                    description: session.systemPrompt || '',
                    personality: roleplayConfig.roleDescription || '',
                    system_prompt: session.systemPrompt || '',
                    character_book: {
                        entries: roleplayConfig.worldBook.map((item, index) => ({
                            keys: [item.key || `world_${index + 1}`],
                            content: item.content || '',
                            enabled: true,
                            insertion_order: index
                        }))
                    },
                    extensions: {
                        echoai_presets: roleplayConfig.presets
                    }
                }
            };

            const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${(roleplayConfig.roleName || 'echoai-role').replace(/\s+/g, '-')}.json`;
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
        }

        function applyRole() {
            const session = sessions[currentSessionId];
            if (!session) return;

            const customPrompt = document.getElementById('customPromptInput').value.trim();
            session.systemPrompt = customPrompt;

            const roleplayConfig = ensureRoleplayConfig(session);
            roleplayConfig.roleName = document.getElementById('roleNameInput').value.trim();
            roleplayConfig.roleDescription = document.getElementById('roleDescriptionInput').value.trim();
            roleplayConfig.worldBook = parseMultiLinePairs(document.getElementById('worldBookInput').value.trim(), 'ä¸–ç•Œä¹¦');
            roleplayConfig.presets = parseMultiLinePairs(document.getElementById('presetInput').value.trim(), 'é¢„è®¾').map(item => ({ name: item.key, content: item.content }));

            saveSessionsToStorage();
            updateHeaderInfo();
            closeRoleSelector();
        }

        function closeRoleSelector() {
            const roleModal = document.getElementById('roleModal');
            if (roleModal) {
                roleModal.style.display = 'none';
            }
            selectedRoleId = null;
        }

        function openSkillTrainingModal() {
            if (!skillTrainingModal) return;
            skillTrainingModal.style.display = 'flex';
            if (skillTrainingInput) {
                skillTrainingInput.value = '';
                setTimeout(() => skillTrainingInput.focus(), 80);
            }
        }

        function closeSkillTrainingModal() {
            if (skillTrainingModal) {
                skillTrainingModal.style.display = 'none';
            }
        }

        async function confirmSkillTraining() {
            const session = sessions[currentSessionId];
            if (!session || session.featureType !== 'qaTest') return;

            const skill = (skillTrainingInput?.value || '').trim();
            if (!skill) {
                alert('è¯·å…ˆè¾“å…¥è¦å­¦ä¹ çš„æŠ€èƒ½');
                return;
            }

            session.quizState = session.quizState || {};
            Object.assign(session.quizState, {
                mode: 'skillTraining',
                status: 'in_progress',
                skill,
                answeredCount: 0,
                score: 0,
                recentQuestions: [],
                reinforcementQueue: [],
                history: [],
                currentQuestion: null
            });
            session.title = `æŠ€èƒ½è®­ç»ƒï¼š${skill}`;
            saveSessionsToStorage();
            updateHeaderInfo();
            closeSkillTrainingModal();

            appendMessageToUI(`å·²ä¸ºä½ å¼€å¯ **${skill}** æŠ€èƒ½è®­ç»ƒã€‚

é¢˜å‹åŒ…å«é€‰æ‹©é¢˜å’Œå¡«ç©ºé¢˜ï¼Œè®­ç»ƒå°†æŒç»­è¿›è¡Œå¹¶åŠ¨æ€æ›´æ–°æŒæ¡åº¦ã€‚å¼€å§‹å‡ºé¢˜ä¸­...`, 'ai');
            renderSkillTrainingDashboard(session.quizState);
            await requestNextSkillQuestion();
        }

        async function requestNextSkillQuestion() {
            const session = sessions[currentSessionId];
            if (!session || session.featureType !== 'qaTest' || !session.quizState) return;
            const quizState = session.quizState;

            const questionNo = quizState.answeredCount + 1;
            const questionData = await requestSkillTrainingQuestion(session, questionNo);
            if (!questionData) {
                appendMessageToUI('å‡ºé¢˜å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•ã€‚', 'ai');
                return;
            }

            quizState.currentQuestion = questionData;
            saveSessionsToStorage();
            renderSkillQuestion(questionData, questionNo);
        }

        function renderSkillQuestion(questionData, questionNo) {
            const questionType = questionData.type === 'blank' ? 'å¡«ç©ºé¢˜' : 'é€‰æ‹©é¢˜';
            let questionText = `ç¬¬ ${questionNo} é¢˜ï¼ˆ${questionType}ï¼‰

${questionData.question}`;
            if (questionData.type === 'blank') {
                questionText += `

è¯·åœ¨è¾“å…¥æ¡†ä½œç­”åå‘é€ã€‚`;
            }
            appendMessageToUI(questionText, 'ai');

            if (questionData.type === 'choice') {
                showChoiceQuestionModal(questionData, questionNo);
            }
        }

        function showChoiceQuestionModal(questionData, questionNo) {
            let modal = document.getElementById('choiceQuestionModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'choiceQuestionModal';
                modal.className = 'modal';
                modal.innerHTML = `
                    <div class="modal-content choice-question-modal-content">
                        <div class="modal-header">ğŸ“ é€‰æ‹©é¢˜ä½œç­”</div>
                        <p id="choiceQuestionProgress" class="choice-question-progress"></p>
                        <p id="choiceQuestionTitle" class="choice-question-title"></p>
                        <div id="choiceQuestionOptions" class="choice-question-options"></div>
                    </div>
                `;
                document.body.appendChild(modal);
            }

            modal.querySelector('#choiceQuestionProgress').textContent = `ç¬¬ ${questionNo} é¢˜`;
            modal.querySelector('#choiceQuestionTitle').textContent = questionData.question;
            const optionsEl = modal.querySelector('#choiceQuestionOptions');
            optionsEl.innerHTML = '';

            (questionData.options || []).forEach((option, idx) => {
                const btn = document.createElement('button');
                btn.className = 'choice-option-btn';
                btn.textContent = `${String.fromCharCode(65 + idx)}. ${option}`;
                btn.onclick = async () => {
                    modal.style.display = 'none';
                    await submitSkillTrainingAnswer({
                        answer: option,
                        answerIndex: idx,
                        answerLabel: String.fromCharCode(65 + idx)
                    });
                };
                optionsEl.appendChild(btn);
            });

            modal.style.display = 'flex';
        }

        async function submitSkillTrainingAnswer(answerPayload) {
            const session = sessions[currentSessionId];
            if (!session || !session.quizState || !session.quizState.currentQuestion) return;

            const quizState = session.quizState;
            const currentQuestion = quizState.currentQuestion;
            const userAnswerText = typeof answerPayload === 'string' ? answerPayload : answerPayload.answer;

            updateSession(userAnswerText, 'user');
            appendMessageToUI(userAnswerText, 'user');

            const evaluation = await evaluateSkillAnswer(session, currentQuestion, answerPayload);
            quizState.history.push({
                question: currentQuestion.question,
                type: currentQuestion.type,
                options: currentQuestion.options || [],
                correctAnswer: currentQuestion.correctAnswer,
                userAnswer: userAnswerText,
                isCorrect: !!evaluation.isCorrect,
                feedback: evaluation.feedback || ''
            });
            updateSkillScore(quizState, !!evaluation.isCorrect);
            quizState.answeredCount += 1;
            quizState.currentQuestion = null;

            if (!evaluation.isCorrect) {
                quizState.reinforcementQueue.push({
                    question: currentQuestion.question,
                    correctAnswer: currentQuestion.correctAnswer,
                    explanation: currentQuestion.explanation || ''
                });
            }

            appendMessageToUI(`ç¬¬ ${quizState.answeredCount} é¢˜å®Œæˆï¼š${evaluation.feedback || (evaluation.isCorrect ? 'å›ç­”æ­£ç¡®ã€‚' : 'å›ç­”ä¸æ­£ç¡®ã€‚')}`, 'ai');
            await maybeSendReinforcement(session);
            renderSkillTrainingDashboard(quizState);
            saveSessionsToStorage();

            await requestNextSkillQuestion();
        }

        async function requestSkillTrainingQuestion(session, questionNo) {
            const recentQuestions = (session.quizState.recentQuestions || []).slice(-8);
            const systemPrompt = `ä½ æ˜¯ä¸€åä¸¥è°¨çš„å‡ºé¢˜è€å¸ˆã€‚å›´ç»•æŠ€èƒ½ã€Œ${session.quizState.skill}ã€å‡ºä¸€é“é¢˜ã€‚å¿…é¡»åœ¨é€‰æ‹©é¢˜(choice)å’Œå¡«ç©ºé¢˜(blank)ä¹‹é—´äº¤æ›¿ï¼Œä¸”åªè¾“å‡º JSONï¼Œä¸è¦ Markdownã€‚é¿å…å’Œå†å²é¢˜ç›®é‡å¤ã€‚`;
            const messages = [{
                role: 'user',
                content: `è¯·è¾“å‡ºç¬¬${questionNo}é¢˜ï¼Œè¿”å› JSON æ ¼å¼ï¼š{"type":"choice|blank","question":"...","options":["..."],"correctAnswer":"...","explanation":"..."}ã€‚å½“ type ä¸º blank æ—¶ options ä¼ ç©ºæ•°ç»„ã€‚
æœ€è¿‘é¢˜å¹²ï¼ˆç¦æ­¢é‡å¤ï¼‰ï¼š${JSON.stringify(recentQuestions)}`
            }];

            for (let attempt = 0; attempt < 3; attempt++) {
                const text = await requestPlainAiResponse(systemPrompt, messages);
                const parsed = safeParseJson(text);
                if (!parsed?.question) continue;
                const normalized = normalizeQuestionText(parsed.question);
                if (!recentQuestions.some(q => normalizeQuestionText(q) === normalized)) {
                    session.quizState.recentQuestions.push(parsed.question);
                    session.quizState.recentQuestions = session.quizState.recentQuestions.slice(-20);
                    return parsed;
                }
            }

            return {
                type: questionNo % 2 === 0 ? 'blank' : 'choice',
                question: `è¯·ç”¨ä¸€å¥è¯è§£é‡Šã€Œ${session.quizState.skill}ã€ä¸­çš„æ ¸å¿ƒæ¦‚å¿µï¼Œå¹¶ä¸¾ä¸€ä¸ªå®é™…åº”ç”¨åœºæ™¯ã€‚`,
                options: [],
                correctAnswer: 'èƒ½å‡†ç¡®è§£é‡Šæ¦‚å¿µå¹¶ç»™å‡ºåˆç†åœºæ™¯',
                explanation: 'è¯¥é¢˜ç”¨äºå¼€æ”¾æ€§å·©å›ºï¼Œé‡ç‚¹åœ¨ç†è§£ä¸åº”ç”¨ã€‚'
            };
        }

        function normalizeQuestionText(text) {
            return String(text || '').replace(/\s+/g, '').toLowerCase();
        }

        function updateSkillScore(quizState, isCorrect) {
            const delta = isCorrect ? 6 : -4;
            quizState.score = Math.max(0, Math.min(100, (quizState.score || 0) + delta));
        }

        async function maybeSendReinforcement(session) {
            const quizState = session.quizState;
            if (!quizState || quizState.answeredCount < 3 || quizState.answeredCount % 3 !== 0) return;
            if (!quizState.reinforcementQueue || quizState.reinforcementQueue.length === 0) return;

            const wrong = quizState.reinforcementQueue.shift();
            appendMessageToUI(`ğŸ“Œ é”™é¢˜å·©å›ºï¼š
ã€Œ${wrong.question}ã€
å‚è€ƒç­”æ¡ˆï¼š${wrong.correctAnswer || 'ï¼ˆæš‚æ— ï¼‰'}
${wrong.explanation ? `è§£æï¼š${wrong.explanation}` : 'è§£æï¼šè¿™é¢˜è€ƒå¯Ÿçš„æ˜¯åŸºç¡€æ¦‚å¿µè¾¨æï¼Œè¯·å…³æ³¨å…³é”®è¯å®šä¹‰ã€‚'}`, 'ai');
        }

        function renderSkillTrainingDashboard(quizState) {
            const dashboard = document.getElementById('skillTrainingDashboard');
            if (!dashboard) return;

            if (!quizState || quizState.status !== 'in_progress') {
                dashboard.style.display = 'none';
                return;
            }

            const score = Math.max(0, Math.min(100, Number(quizState.score) || 0));
            document.getElementById('skillDashboardTitle').textContent = `ğŸ§  ${quizState.skill} æŠ€èƒ½è®­ç»ƒ`;
            document.getElementById('skillDashboardMeta').textContent = `å·²ç­” ${quizState.answeredCount} é¢˜ Â· åŠ¨æ€æŒæ¡åº¦ ${score} åˆ†`;
            document.getElementById('skillDashboardBar').style.width = `${score}%`;
            dashboard.style.display = 'block';
        }

        async function evaluateSkillAnswer(session, question, answerPayload) {
            const userAnswer = typeof answerPayload === 'string' ? answerPayload : answerPayload.answer;
            const systemPrompt = 'ä½ æ˜¯ä¸€åé˜…å·è€å¸ˆï¼Œåªè¿”å› JSONã€‚';
            const messages = [{
                role: 'user',
                content: `é¢˜ç›®ï¼š${question.question}
æ ‡å‡†ç­”æ¡ˆï¼š${question.correctAnswer}
ç”¨æˆ·ç­”æ¡ˆï¼š${userAnswer}
è¯·åˆ¤æ–­æ˜¯å¦æ­£ç¡®ï¼Œè¿”å› {"isCorrect":true/false,"feedback":"ä¸è¶…è¿‡30å­—"}`
            }];

            const text = await requestPlainAiResponse(systemPrompt, messages);
            const parsed = safeParseJson(text);
            if (parsed && typeof parsed.isCorrect === 'boolean') return parsed;

            const normalizedCorrect = String(question.correctAnswer || '').trim().toLowerCase();
            const normalizedUser = String(userAnswer || '').trim().toLowerCase();
            const isCorrect = normalizedCorrect && normalizedCorrect === normalizedUser;
            return { isCorrect, feedback: isCorrect ? 'å›ç­”æ­£ç¡®ã€‚' : `å‚è€ƒç­”æ¡ˆï¼š${question.correctAnswer || 'æ— '}` };
        }

        async function finalizeSkillTraining() {
            const session = sessions[currentSessionId];
            if (!session || !session.quizState) return;
            const quizState = session.quizState;

            const systemPrompt = 'ä½ æ˜¯ä¸€åå­¦ä¹ è¯„ä¼°ä¸“å®¶ã€‚æ ¹æ®ç­”é¢˜è®°å½•ï¼Œç»™å‡º0-100åˆ†æŒæ¡åº¦ã€‚åªè¿”å›JSONã€‚';
            const messages = [{
                role: 'user',
                content: `æŠ€èƒ½ï¼š${quizState.skill}
ç­”é¢˜è®°å½•ï¼š${JSON.stringify(quizState.history)}
è¿”å› {"score":æ•°å­—,"summary":"ä¸è¶…è¿‡60å­—"}`
            }];
            const text = await requestPlainAiResponse(systemPrompt, messages);
            const result = safeParseJson(text) || {};
            const total = Math.max(1, quizState.history.length);
            const score = Math.max(0, Math.min(100, Number(result.score) || Math.round((quizState.history.filter(h => h.isCorrect).length / total) * 100)));
            const summary = result.summary || 'è®­ç»ƒå®Œæˆï¼Œç»§ç»­å·©å›ºå¯è¿›ä¸€æ­¥æå‡ã€‚';

            quizState.status = 'in_progress';
            session.title = `${quizState.skill} æŒæ¡åº¦ï¼š${score}/100`;
            saveSessionsToStorage();
            updateHeaderInfo();

            appendMessageToUI(`âœ… æŠ€èƒ½è®­ç»ƒå®Œæˆï¼

å½“å‰ã€Œ${quizState.skill}ã€æŒæ¡åº¦ï¼š**${score}/100**
${summary}`, 'ai');
        }

        async function requestPlainAiResponse(systemPrompt, messages) {
            const config = getSettings();
            const payload = {
                model: config.model,
                temperature: 0.4,
                stream: false,
                messages: [{ role: 'system', content: systemPrompt }, ...messages]
            };

            const response = await fetch(config.apiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${config.apiKey}`
                },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                throw new Error(`å‡ºé¢˜è¯·æ±‚å¤±è´¥: ${response.status}`);
            }
            const data = await response.json();
            return data?.choices?.[0]?.message?.content || '';
        }

        function safeParseJson(text) {
            if (!text) return null;
            try {
                return JSON.parse(text);
            } catch (e) {
                const match = text.match(/\{[\s\S]*\}/);
                if (!match) return null;
                try {
                    return JSON.parse(match[0]);
                } catch (error) {
                    return null;
                }
            }
        }

        function updateSession(content, role) {
            if (!currentSessionId || !sessions[currentSessionId]) {
                startNewChat(); // é˜²å¾¡æ€§ç¼–ç¨‹
            }
            
            const session = sessions[currentSessionId];
            session.messages.push({ role, content });
            session.timestamp = Date.now(); // æ›´æ–°æ—¶é—´æˆ³ä»¥ä¾¿æ’åº

            // ç®€å•é¢„è®¾æ ‡é¢˜ (å¦‚æœæ˜¯ç¬¬ä¸€æ¡ç”¨æˆ·æ¶ˆæ¯)ï¼Œåç»­ä¼šé€šè¿‡ AI ä¼˜åŒ–
            if (session.messages.length === 1 && role === 'user' && session.featureType !== 'qaTest') {
                session.title = content.substring(0, 20) + (content.length > 20 ? '...' : '');
            }

            saveSessionsToStorage();
            updateHeaderInfo();
            return session.messages.length - 1; // è¿”å›æ–°æ¶ˆæ¯çš„ç´¢å¼•
        }

        // --- æ¶ˆæ¯å‘é€é€»è¾‘ ---

        function appendMessageToUI(text, sender, useTypewriter = false, index = null) {
            const container = document.createElement('div');
            container.className = `message-container ${sender === 'user' ? 'user' : 'ai'}`;
            const avatarText = sender === 'user' ? 'æˆ‘' : 'AI';
            
            // ä½¿ç”¨ marked è§£æ Markdown
            marked.setOptions({
                breaks: true,
                gfm: true
            });

            // æ“ä½œæŒ‰é’®
            let actionsHtml = '';
            if (index !== null) {
                // åªæœ‰å·²ä¿å­˜çš„æ¶ˆæ¯æ‰æœ‰ indexï¼Œæ‰æ˜¾ç¤ºæ“ä½œæŒ‰é’®
                actionsHtml += `<button class="message-action-btn" onclick="copyMessage(this)" title="å¤åˆ¶å†…å®¹">ğŸ“‹</button>`;
                if (sender === 'ai') {
                    actionsHtml += `<button class="message-action-btn" onclick="regenerateMessage(${index})" title="é‡æ–°ç”Ÿæˆ">ğŸ”„</button>`;
                }
                actionsHtml += `<button class="message-action-btn" onclick="deleteMessage(${index})" title="åˆ é™¤">ğŸ—‘ï¸</button>`;
            }

            // å…ˆåˆ›å»ºåŸºæœ¬ç»“æ„
            container.innerHTML = `
                <div class="avatar ${sender === 'user' ? 'user' : 'ai'}">${avatarText}</div>
                <div class="content-wrapper">
                    <div class="message-content"></div>
                    <div class="message-actions">${actionsHtml}</div>
                </div>
            `;
            chatMessages.appendChild(container);
            
            const contentEl = container.querySelector('.message-content');
            
            // å­˜å‚¨åŸå§‹å†…å®¹ç”¨äºå¤åˆ¶
            contentEl.dataset.raw = text;
            
            if (useTypewriter && sender === 'ai') {
                let i = 0;
                const step = 2; 
                contentEl.innerHTML = '';

                function type() {
                    if (i < text.length) {
                        i += step;
                        const currentText = text.substring(0, i);
                        // ğŸ”’ ä½¿ç”¨å®‰å…¨çš„ Markdown æ¸²æŸ“
                        contentEl.innerHTML = safeMarkdownRender(currentText);
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                        setTimeout(type, 30);
                    } else {
                        contentEl.innerHTML = safeMarkdownRender(text);
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                        appendImageBubbleActions(container, text, sender, index);
                    }
                }
                type();
            } else {
                // ğŸ”’ ä½¿ç”¨å®‰å…¨çš„ Markdown æ¸²æŸ“
                contentEl.innerHTML = safeMarkdownRender(text);
                chatMessages.scrollTop = chatMessages.scrollHeight;
                appendImageBubbleActions(container, text, sender, index);
            }
        }

        function extractImageUrls(text = '') {
            const urls = [];
            const mdRegex = /!\[[^\]]*\]\(([^)]+)\)/g;
            const directRegex = /(data:image\/[^;]+;base64,[A-Za-z0-9+/=]+|https?:\/\/[^\s"'<>]+\.(?:png|jpe?g|gif|webp))/ig;
            let match;

            while ((match = mdRegex.exec(text)) !== null) {
                urls.push(match[1]);
            }
            while ((match = directRegex.exec(text)) !== null) {
                urls.push(match[1]);
            }

            return [...new Set(urls)];
        }

        function appendImageBubbleActions(container, text, sender, index) {
            if (sender !== 'ai') return;
            const imageUrls = extractImageUrls(text);
            if (imageUrls.length === 0) return;
            const firstImage = imageUrls[0];

            const btnBar = document.createElement('div');
            btnBar.className = 'image-bubble-actions';
            btnBar.innerHTML = `
                <button onclick="downloadImageByUrl('${firstImage}')">ğŸ’¾ ä¸‹è½½</button>
                <button onclick="reuseImageAsReference('${firstImage}', 'è¯·åŸºäºè¿™å¼ å›¾ç”Ÿæˆç›¸ä¼¼é£æ ¼çš„æ–°ç‰ˆæœ¬')">ğŸ” ç›¸ä¼¼é‡ç»˜</button>
                <button onclick="openImageModal('${firstImage}')">ğŸ” æ”¾å¤§é¢„è§ˆ</button>
                <button onclick="reuseImageAsReference('${firstImage}', 'è¯·æ”¹ç”¨æ°´å½©é£æ ¼é‡ç”»è¿™å¼ å›¾')">ğŸ¨ æ°´å½©é‡ç”»</button>
            `;
            container.querySelector('.content-wrapper')?.appendChild(btnBar);
        }

        function downloadImageByUrl(imageUrl) {
            if (!imageUrl) return;
            const link = document.createElement('a');
            link.href = imageUrl;
            link.download = `echoai-image-${Date.now()}.png`;
            link.target = '_blank';
            link.rel = 'noopener';
            link.click();
        }

        async function reuseImageAsReference(imageUrl, promptText) {
            if (!imageUrl) return;
            selectedImageBase64 = imageUrl;
            document.getElementById('imagePreview').src = imageUrl;
            document.getElementById('imagePreviewContainer').style.display = 'block';
            userInput.value = promptText || 'è¯·åŸºäºè¿™å¼ å›¾ç»§ç»­é‡ç»˜';
            userInput.focus();
        }

        function getLastSessionImage(session) {
            if (!session?.messages?.length) return null;
            for (let i = session.messages.length - 1; i >= 0; i--) {
                const msg = session.messages[i];
                if (msg.role !== 'assistant') continue;
                const found = extractImageUrls(msg.content || '');
                if (found.length > 0) return found[0];
            }
            return null;
        }

        function showLoadingIndicator() {
            const loadingDiv = document.createElement('div');
            loadingDiv.id = 'loadingIndicator';
            loadingDiv.className = 'loading-indicator';
            loadingDiv.innerHTML = `
                <div class="loading-dot"></div>
                <div class="loading-dot"></div>
                <div class="loading-dot"></div>
            `;
            chatMessages.appendChild(loadingDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function removeLoadingIndicator() {
            const loadingDiv = document.getElementById('loadingIndicator');
            if (loadingDiv) loadingDiv.remove();
        }

        async function sendMessage() {
            const rawText = userInput.value;
            let autoRefImage = null;

            const currentSession = sessions[currentSessionId];
            if (currentSession?.isImageChat && !selectedImageBase64 && rawText.trim()) {
                if (/(è¿™å¼ å›¾|ä¸Šä¸€å¼ |é‡ç”»|æ”¹ç”¨|é£æ ¼|åŸºäºè¿™å¼ )/.test(rawText)) {
                    autoRefImage = getLastSessionImage(currentSession);
                }
            }

            const activeImage = selectedImageBase64 || autoRefImage;
            const hasImage = activeImage !== null;
            if (currentSession?.featureType === 'qaTest') {
                const quizState = currentSession.quizState;
                if (quizState?.status === 'setup') {
                    openSkillTrainingModal();
                    return;
                }
                if (quizState?.status === 'in_progress' && quizState?.currentQuestion?.type === 'choice') {
                    alert('è¯·å…ˆåœ¨å¼¹å‡ºçš„å¡ç‰‡ä¸­é€‰æ‹©ç­”æ¡ˆ');
                    return;
                }
                if (quizState?.status === 'in_progress' && quizState?.currentQuestion?.type === 'blank') {
                    const answer = rawText.trim();
                    if (!answer) {
                        alert('è¯·å…ˆè¾“å…¥å¡«ç©ºé¢˜ç­”æ¡ˆ');
                        return;
                    }
                    userInput.value = '';
                    await submitSkillTrainingAnswer(answer);
                    return;
                }
            }

            if (isRequestInFlight) {
                alert('æ­£åœ¨ç­‰å¾… AI å›å¤ï¼Œè¯·ç¨åå†å‘é€');
                return;
            }
            
            // ğŸ”’ å®‰å…¨éªŒè¯ï¼šè¾“å…¥å†…å®¹ï¼ˆå¦‚æœæœ‰å›¾ç‰‡ï¼Œæ–‡æœ¬å¯ä»¥ä¸ºç©ºï¼‰
            if (!hasImage) {
                const inputValidation = validateInput(rawText);
                if (!inputValidation.valid) {
                    alert(inputValidation.error);
                    return;
                }
            }
            const text = rawText.trim() || (hasImage ? '[å›¾ç‰‡]' : '');
            
            if (!text && !hasImage) {
                alert('è¯·è¾“å…¥å†…å®¹æˆ–ä¸Šä¼ å›¾ç‰‡');
                return;
            }

            // ğŸ”’ å®‰å…¨éªŒè¯ï¼šé€Ÿç‡é™åˆ¶
            const rateCheck = checkRateLimit();
            if (!rateCheck.allowed) {
                alert(rateCheck.error);
                return;
            }

            const config = getSettings();
            if (!config.apiKey) {
                alert('è¯·å…ˆç‚¹å‡»å³ä¸Šè§’è®¾ç½®æŒ‰é’®é…ç½® API Key');
                openSettings();
                return;
            }

            // è®°å½•è¯·æ±‚æ—¶é—´
            isRequestInFlight = true;
            recordRequest();

            // ä¿å­˜å½“å‰å›¾ç‰‡ä¿¡æ¯
            const currentImageBase64 = activeImage;
            
            userInput.value = '';
            sendBtn.disabled = true;
            
            // æ¸…é™¤å›¾ç‰‡é¢„è§ˆ
            removeImage();

            // 1. UI æ˜¾ç¤º & ä¿å­˜æ•°æ®
            const displayContent = hasImage ? { text, image: currentImageBase64 } : text;
            const userMsgIndex = updateSession(typeof displayContent === 'object' ? JSON.stringify(displayContent) : text, 'user');
            appendMessageWithImageToUI(text, currentImageBase64, 'user', userMsgIndex);

            // æ˜¾ç¤ºåŠ è½½ä¸­
            showLoadingIndicator();

            await performAiRequest(config, currentImageBase64);
        }
        
        // æ”¯æŒæ˜¾ç¤ºå¸¦å›¾ç‰‡çš„æ¶ˆæ¯
        function appendMessageWithImageToUI(text, imageBase64, sender, index = null) {
            const container = document.createElement('div');
            container.className = `message-container ${sender === 'user' ? 'user' : 'ai'}`;
            const avatarText = sender === 'user' ? 'æˆ‘' : 'AI';
            
            // æ“ä½œæŒ‰é’®
            let actionsHtml = '';
            if (index !== null) {
                actionsHtml += `<button class="message-action-btn" onclick="copyMessage(this)" title="å¤åˆ¶å†…å®¹">ğŸ“‹</button>`;
                if (sender === 'ai') {
                    actionsHtml += `<button class="message-action-btn" onclick="regenerateMessage(${index})" title="é‡æ–°ç”Ÿæˆ">ğŸ”„</button>`;
                }
                actionsHtml += `<button class="message-action-btn" onclick="deleteMessage(${index})" title="åˆ é™¤">ğŸ—‘ï¸</button>`;
            }

            // æ„å»ºå†…å®¹ HTML
            let contentHtml = '';
            if (imageBase64) {
                contentHtml += `<img src="${imageBase64}" class="message-image" onclick="openImageModal('${imageBase64}')" alt="ç”¨æˆ·ä¸Šä¼ çš„å›¾ç‰‡">`;
            }
            if (text && text !== '[å›¾ç‰‡]') {
                contentHtml += `<div>${safeMarkdownRender(text)}</div>`;
            }

            container.innerHTML = `
                <div class="avatar ${sender === 'user' ? 'user' : 'ai'}">${avatarText}</div>
                <div class="content-wrapper">
                    <div class="message-content">${contentHtml}</div>
                    <div class="message-actions">${actionsHtml}</div>
                </div>
            `;
            
            const contentEl = container.querySelector('.message-content');
            contentEl.dataset.raw = text;
            
            chatMessages.appendChild(container);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        async function performAiRequest(config, imageBase64 = null) {
            const session = sessions[currentSessionId];
            
            // ä¼˜åŒ–ï¼šä½¿ç”¨ contextLimit è®¾ç½®
            const limit = config.contextLimit !== undefined ? config.contextLimit : DEFAULT_CONFIG.contextLimit;
            let safeLimit = limit;
            if (safeLimit < 1) safeLimit = 1;

            // æ„å»ºä¸Šä¸‹æ–‡æ¶ˆæ¯ï¼Œæ”¯æŒå¤šæ¨¡æ€
            let contextMessages = session.messages.slice(-safeLimit).map((m, idx) => {
                // æ£€æŸ¥æœ€åä¸€æ¡ç”¨æˆ·æ¶ˆæ¯æ˜¯å¦éœ€è¦é™„åŠ å›¾ç‰‡
                const isLastUserMsg = idx === session.messages.slice(-safeLimit).length - 1 && m.role === 'user';
                
                if (isLastUserMsg && imageBase64) {
                    // å¤šæ¨¡æ€æ¶ˆæ¯æ ¼å¼ï¼ˆOpenAI Vision API æ ¼å¼ï¼‰
                    return {
                        role: m.role,
                        content: [
                            {
                                type: "text",
                                text: m.content
                            },
                            {
                                type: "image_url",
                                image_url: {
                                    url: imageBase64
                                }
                            }
                        ]
                    };
                }
                
                return { role: m.role, content: m.content };
            });

            // å¦‚æœè®¾ç½®äº†ç³»ç»Ÿæç¤ºè¯ï¼Œæ·»åŠ åˆ°æ¶ˆæ¯å¼€å¤´
            const effectiveSystemPrompt = buildEffectiveSystemPrompt(session);
            if (effectiveSystemPrompt) {
                contextMessages.unshift({ role: 'system', content: effectiveSystemPrompt });
            }

            // æ˜¯å¦ä½¿ç”¨æµå¼è¾“å‡ºï¼ˆçœŸæ­£çš„ SSE æµå¼ï¼‰
            // å¦‚æœæ¨¡å‹åç§°åŒ…å« image æˆ– flash-exp (gemini)ï¼Œå¼ºåˆ¶å…³é—­æµå¼ï¼Œå› ä¸ºå›¾ç‰‡ç”Ÿæˆé€šå¸¸ä¸æ”¯æŒæµå¼
            let useStream = config.stream !== undefined ? config.stream : DEFAULT_CONFIG.stream;
            if (config.model.includes('image') || config.model.includes('gemini')) {
                useStream = false;
            }

            const payload = {
                model: config.model,
                messages: contextMessages,
                temperature: parseFloat(config.temperature || DEFAULT_CONFIG.temperature),
                stream: useStream // å‘Šè¯‰ API ä½¿ç”¨æµå¼
            };

            if (config.enableMaxTokens) {
                payload.max_tokens = parseInt(config.maxTokens || DEFAULT_CONFIG.maxTokens);
            }

            try {
                const response = await fetch(config.apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${config.apiKey}`
                    },
                    body: JSON.stringify(payload)
                });

                removeLoadingIndicator();

                if (!response.ok) {
                    const errData = await response.json().catch(() => ({}));
                    throw new Error(errData.error?.message || `HTTP error! status: ${response.status}`);
                }

                if (useStream) {
                    // --- çœŸæ­£çš„æµå¼å¤„ç† ---
                    // å…ˆåˆ›å»ºæ¶ˆæ¯å®¹å™¨
                    const container = document.createElement('div');
                    container.className = 'message-container ai';
                    container.innerHTML = `
                        <div class="avatar ai">AI</div>
                        <div class="content-wrapper">
                            <div class="message-content"></div>
                            <div class="message-actions"></div>
                        </div>
                    `;
                    chatMessages.appendChild(container);
                    const contentEl = container.querySelector('.message-content');
                    const actionsEl = container.querySelector('.message-actions');
                    
                    let fullText = '';
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;

                        const chunk = decoder.decode(value, { stream: true });
                        // SSE æ ¼å¼ï¼šdata: {...}\n\n
                        const lines = chunk.split('\n');
                        for (const line of lines) {
                            const trimmedLine = line.trim();
                            if (trimmedLine.startsWith('data: ')) {
                                const data = trimmedLine.slice(6);
                                if (data === '[DONE]') continue;
                                try {
                                    const json = JSON.parse(data);
                                    const content = json.choices?.[0]?.delta?.content;
                                    if (content) {
                                        fullText += content;
                                        // ğŸ”’ ä½¿ç”¨å®‰å…¨çš„ Markdown æ¸²æŸ“
                                        contentEl.innerHTML = safeMarkdownRender(fullText);
                                        chatMessages.scrollTop = chatMessages.scrollHeight;
                                    }
                                } catch (e) {
                                    // JSON è§£æå¤±è´¥ï¼Œå¿½ç•¥ï¼ˆå¯èƒ½æ˜¯ä¸å®Œæ•´çš„å—ï¼‰
                                }
                            }
                        }
                    }
                    
                    // æµç»“æŸï¼Œä¿å­˜æ¶ˆæ¯
                    if (fullText.trim()) {
                        const aiMsgIndex = updateSession(fullText, 'assistant');
                        // æ·»åŠ æ“ä½œæŒ‰é’®
                        contentEl.dataset.raw = fullText;
                        actionsEl.innerHTML = `
                            <button class="message-action-btn" onclick="copyMessage(this)" title="å¤åˆ¶å†…å®¹">ğŸ“‹</button>
                            <button class="message-action-btn" onclick="regenerateMessage(${aiMsgIndex})" title="é‡æ–°ç”Ÿæˆ">ğŸ”„</button>
                            <button class="message-action-btn" onclick="deleteMessage(${aiMsgIndex})" title="åˆ é™¤">ğŸ—‘ï¸</button>
                        `;
                        
                        // å°è¯•ç”Ÿæˆ AI æ ‡é¢˜ï¼šé¦–æ¬¡å¯¹è¯æˆ–æŒ‰è®¾ç½®é—´éš”
                        const msgCount = session.messages.length;
                        const titleRegenInterval = config.titleRegenInterval !== undefined ? config.titleRegenInterval : 5;
                        const shouldRegenTitle = msgCount === 2 || (titleRegenInterval > 0 && msgCount > 2 && (msgCount - 2) % (titleRegenInterval * 2) === 0);
                        if (shouldRegenTitle) {
                            console.log(`æ ‡é¢˜é‡ç”Ÿæˆè§¦å‘: msgCount=${msgCount}, interval=${titleRegenInterval}`);
                            generateTitle(currentSessionId);
                        }
                        
                        // è‡ªåŠ¨åˆ é™¤æœ€æ—©çš„æ¶ˆæ¯
                        if (config.autoDeleteOldest && session.messages.length > 2) {
                            session.messages.shift(); // åˆ é™¤ç¬¬ä¸€æ¡æ¶ˆæ¯
                            console.log('è‡ªåŠ¨åˆ é™¤æœ€æ—©æ¶ˆæ¯ï¼Œå½“å‰æ¶ˆæ¯æ•°:', session.messages.length);
                            saveSessionsToStorage();
                            updateHeaderInfo();
                        }
                    }

                } else {
                    // --- éæµå¼å¤„ç†ï¼ˆåŸé€»è¾‘ï¼‰ ---
                    const data = await response.json();
                    
                    // å°è¯•æå–å†…å®¹å’Œå›¾ç‰‡
                    let aiResponse = data.choices[0].message.content || '';
                    let imageUrl = null;

                    // 1. æ£€æŸ¥æ˜¯å¦æœ‰ Base64 å›¾ç‰‡ (data:image/...)
                    const base64Match = aiResponse.match(/data:image\/[^;]+;base64,[A-Za-z0-9+/=]+/);
                    if (base64Match) {
                        imageUrl = base64Match[0];
                        // å¯ä»¥é€‰æ‹©æ˜¯å¦ä»æ–‡æœ¬ä¸­ç§»é™¤ Base64 å­—ç¬¦ä¸²ï¼Œé¿å…æ˜¾ç¤ºå¤ªé•¿
                        // aiResponse = aiResponse.replace(base64Match[0], '[å›¾ç‰‡å·²ç”Ÿæˆ]');
                    }
                    
                    // 2. æ£€æŸ¥æ˜¯å¦æœ‰ Markdown å›¾ç‰‡é“¾æ¥
                    if (!imageUrl) {
                        const mdMatch = aiResponse.match(/!\[.*?\]\((https?:\/\/[^\s)]+)\)/);
                        if (mdMatch) {
                            imageUrl = mdMatch[1];
                        }
                    }

                    // 3. æ£€æŸ¥æ˜¯å¦æœ‰ URL å›¾ç‰‡é“¾æ¥
                    if (!imageUrl) {
                        const urlMatch = aiResponse.match(/https?:\/\/[^\s"'<>]+\.(png|jpg|jpeg|gif|webp)/i);
                        if (urlMatch) {
                            imageUrl = urlMatch[0];
                        }
                    }

                    // 4. æ£€æŸ¥ Gemini ç­‰æ¨¡å‹çš„ inline_data (parts)
                    const parts = data.choices?.[0]?.message?.content_parts || data.choices?.[0]?.message?.parts;
                    if (parts && Array.isArray(parts)) {
                        for (const part of parts) {
                            // Gemini æ ¼å¼: { inline_data: { mime_type, data } }
                            if (part.inline_data && part.inline_data.data) {
                                const mimeType = part.inline_data.mime_type || 'image/png';
                                imageUrl = `data:${mimeType};base64,${part.inline_data.data}`;
                                if (!aiResponse) aiResponse = "å›¾ç‰‡ç”ŸæˆæˆåŠŸï¼š";
                                break;
                            }
                            // ä¹Ÿå¯ä»¥æ‹¼æ¥æ–‡æœ¬éƒ¨åˆ†
                            if (part.text) {
                                aiResponse += part.text;
                            }
                        }
                    }

                    // å¦‚æœæå–åˆ°äº†å›¾ç‰‡ï¼Œä¿®æ”¹æ˜¾ç¤ºé€»è¾‘
                    if (imageUrl) {
                        // å°†å›¾ç‰‡è¿½åŠ åˆ°æ–‡æœ¬åé¢ï¼ˆæˆ–è€…ä½œä¸ºç‹¬ç«‹æ¶ˆæ¯ï¼‰
                        // è¿™é‡Œæˆ‘ä»¬é€‰æ‹©æ‹¼æ¥ Markdown å›¾ç‰‡è¯­æ³•ï¼Œè¿™æ · appendMessageToUI é‡Œçš„ marked å°±èƒ½æ¸²æŸ“å®ƒ
                        // æˆ–è€…ä½¿ç”¨ appendMessageWithImageToUI
                        
                        const aiMsgIndex = updateSession(aiResponse, 'assistant'); // ä¿å­˜æ–‡æœ¬
                        // å¦‚æœæœ‰å›¾ç‰‡ï¼Œæˆ‘ä»¬éœ€è¦ä¿å­˜å›¾ç‰‡ä¿¡æ¯ã€‚
                        // ç›®å‰çš„ updateSession æ¯”è¾ƒç®€å•ï¼Œåªå­˜ content stringã€‚
                        // æˆ‘ä»¬å¯ä»¥æŠŠå›¾ç‰‡è½¬æˆ Markdown è¯­æ³•å­˜è¿› contentã€‚
                        
                        if (!aiResponse.includes(imageUrl)) {
                            // å¦‚æœæ˜¯ Base64ï¼Œç›´æ¥æ‹¼æ¥åˆ° Markdown ä¼šå¯¼è‡´å†å²è®°å½•å¤ªå¤§ï¼Œ
                            // ä½†ç”±äºç›®å‰æ˜¯å­˜ LocalStorageï¼Œä¹Ÿåªèƒ½è¿™æ ·ï¼Œæˆ–è€…å•ç‹¬å¤„ç†ã€‚
                            // ä¸ºäº†å…¼å®¹æ€§ï¼Œæˆ‘ä»¬æ„é€  Markdown å›¾ç‰‡è¯­æ³•
                            const imageMarkdown = `\n\n![ç”Ÿæˆçš„å›¾ç‰‡](${imageUrl})`;
                            aiResponse += imageMarkdown;
                            
                            // æ›´æ–°åˆšæ‰ä¿å­˜çš„æ¶ˆæ¯
                            sessions[currentSessionId].messages[aiMsgIndex].content = aiResponse;
                            saveSessionsToStorage();
                        }
                        
                        // æ¸²æŸ“
                        // æ¸…é™¤æ—§çš„æ·»åŠ ï¼Œé‡æ–°æ¸²æŸ“è¿™ä¸€æ¡
                        // ä½†ç”±äºæˆ‘ä»¬å·²ç»è°ƒç”¨äº† updateSessionï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥åˆ·æ–°æˆ–è¿½åŠ 
                        // ä¸ºäº†ç®€å•ï¼Œç›´æ¥è°ƒç”¨ appendMessageToUIï¼Œå®ƒä¼šæ¸²æŸ“ Markdown å›¾ç‰‡
                        appendMessageToUI(aiResponse, 'ai', false, aiMsgIndex);

                    } else {
                        // æ™®é€šæ–‡æœ¬
                        const aiMsgIndex = updateSession(aiResponse, 'assistant');
                        appendMessageToUI(aiResponse, 'ai', false, aiMsgIndex);
                    }
                    
                    // å°è¯•ç”Ÿæˆ AI æ ‡é¢˜ï¼šé¦–æ¬¡å¯¹è¯æˆ–æŒ‰è®¾ç½®é—´éš”
                    const msgCount = session.messages.length;
                    const titleRegenInterval = config.titleRegenInterval !== undefined ? config.titleRegenInterval : 5;
                    const shouldRegenTitle = msgCount === 2 || (titleRegenInterval > 0 && msgCount > 2 && (msgCount - 2) % (titleRegenInterval * 2) === 0);
                    if (shouldRegenTitle) {
                        console.log(`æ ‡é¢˜é‡ç”Ÿæˆè§¦å‘: msgCount=${msgCount}, interval=${titleRegenInterval}`);
                        generateTitle(currentSessionId);
                    }
                    
                    // è‡ªåŠ¨åˆ é™¤æœ€æ—©çš„æ¶ˆæ¯
                    if (config.autoDeleteOldest && session.messages.length > 2) {
                        session.messages.shift();
                        console.log('è‡ªåŠ¨åˆ é™¤æœ€æ—©æ¶ˆæ¯ï¼Œå½“å‰æ¶ˆæ¯æ•°:', session.messages.length);
                        saveSessionsToStorage();
                        updateHeaderInfo();
                    }
                }

            } catch (error) {
                removeLoadingIndicator();
                console.error('API Error:', error);
                let errMsg = `è¯·æ±‚å¤±è´¥: ${error.message}`;
                if (error.message.includes('System is really busy')) {
                    errMsg += "\n(æç¤ºï¼šæœåŠ¡å™¨ç¹å¿™ï¼Œè¯·ç¨åé‡è¯•ã€‚)";
                }
                
                const container = document.createElement('div');
                container.className = 'message-container ai error-message';
                container.innerHTML = `
                    <div class="avatar ai" style="background-color: #dc3545;">!</div>
                    <div class="content-wrapper">
                        <div class="message-content" style="color: #dc3545; background-color: #fff5f5; border: 1px solid #ffcdd2;">${errMsg}</div>
                        <div class="message-actions" style="opacity: 1;">
                            <button class="retry-btn" onclick="retryLastMessage(this)" title="é‡è¯•">ğŸ”„ é‡è¯•</button>
                        </div>
                    </div>
                `;
                chatMessages.appendChild(container);
                chatMessages.scrollTop = chatMessages.scrollHeight;

            } finally {
                isRequestInFlight = false;
                userInput.disabled = false;
                sendBtn.disabled = false;
                userInput.focus();
            }
        }

        function deleteMessage(index) {
            if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡æ¶ˆæ¯å—ï¼Ÿ')) return;
            
            const session = sessions[currentSessionId];
            if (session && session.messages[index]) {
                session.messages.splice(index, 1);
                saveSessionsToStorage();
                switchChat(currentSessionId); // é‡æ–°æ¸²æŸ“
            }
        }

        async function regenerateMessage(index) {
            if (isRequestInFlight) {
                alert('æ­£åœ¨ç­‰å¾… AI å›å¤ï¼Œè¯·ç¨åé‡è¯•');
                return;
            }

            // é‡æ–°ç”Ÿæˆé€»è¾‘ï¼š
            // 1. åˆ é™¤è¯¥æ¡ AI æ¶ˆæ¯ä»¥åŠå…¶åçš„æ‰€æœ‰æ¶ˆæ¯ï¼ˆå› ä¸ºä¸Šä¸‹æ–‡å˜äº†ï¼‰
            // 2. é‡æ–°å‘èµ·è¯·æ±‚
            
            if (!confirm('é‡æ–°ç”Ÿæˆå°†ä¼šåˆ é™¤æ­¤æ¡æ¶ˆæ¯ä¹‹åçš„æ‰€æœ‰å¯¹è¯è®°å½•ï¼Œç¡®å®šç»§ç»­å—ï¼Ÿ')) return;

            const session = sessions[currentSessionId];
            if (!session) return;

            // æˆªæ–­æ•°ç»„ï¼šä¿ç•™ index ä¹‹å‰çš„æ¶ˆæ¯ (0 åˆ° index-1)
            // è¯¥ AI æ¶ˆæ¯ä½äº indexï¼Œæ‰€ä»¥ splice(index) ä¼šåˆ é™¤å®ƒåŠä¹‹åçš„æ‰€æœ‰å†…å®¹
            session.messages.splice(index);
            saveSessionsToStorage();
            
            // é‡æ–°æ¸²æŸ“ UI (å»æ‰å·²åˆ é™¤çš„æ¶ˆæ¯)
            switchChat(currentSessionId);
            
            // æ­¤æ—¶ session.messages å·²ç»æ˜¯æˆªæ–­åçš„çŠ¶æ€
            // å¯ä»¥åœ¨ UI ä¸Šæ˜¾ç¤º Loading å¹¶å‘èµ·è¯·æ±‚
            showLoadingIndicator();
            
            const config = getSettings();
            if (!config.apiKey) {
                removeLoadingIndicator();
                alert('API Key æœªé…ç½®');
                return;
            }
            
            sendBtn.disabled = true;
            isRequestInFlight = true;
            
            await performAiRequest(config);
        }

        function copyMessage(btn) {
            // æ‰¾åˆ°å¯¹åº”çš„ message-content
            // ç»“æ„: btn -> actions -> content-wrapper -> message-content
            const wrapper = btn.closest('.content-wrapper');
            const contentEl = wrapper.querySelector('.message-content');
            const text = contentEl.dataset.raw || contentEl.innerText;
            
            navigator.clipboard.writeText(text).then(() => {
                const originalText = btn.textContent;
                btn.textContent = 'âœ”ï¸';
                setTimeout(() => btn.textContent = originalText, 2000);
            }).catch(err => {
                console.error('å¤åˆ¶å¤±è´¥:', err);
                alert('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶');
            });
        }

        // é‡è¯•ä¸Šä¸€æ¡å¤±è´¥çš„è¯·æ±‚
        async function retryLastMessage(btn) {
            if (isRequestInFlight) {
                alert('æ­£åœ¨ç­‰å¾… AI å›å¤ï¼Œè¯·ç¨åé‡è¯•');
                return;
            }

            // ç§»é™¤é”™è¯¯æ¶ˆæ¯å®¹å™¨
            const errorContainer = btn.closest('.message-container');
            if (errorContainer) {
                errorContainer.remove();
            }
            
            const config = getSettings();
            if (!config.apiKey) {
                alert('API Key æœªé…ç½®');
                openSettings();
                return;
            }
            
            // æ˜¾ç¤ºåŠ è½½ä¸­
            showLoadingIndicator();
            
            sendBtn.disabled = true;
            isRequestInFlight = true;
            
            // é‡æ–°å‘èµ·è¯·æ±‚
            await performAiRequest(config);
        }

        async function regenerateTitle(event, sessionId) {
            event.stopPropagation();
            const btn = event.target;
            
            // ç®€å•çš„é˜²æŠ–/çŠ¶æ€æ˜¾ç¤º
            const originalText = btn.textContent;
            btn.textContent = '...';
            btn.disabled = true;

            await generateTitle(sessionId);

            // æ¢å¤æŒ‰é’®çŠ¶æ€ (å®é™…ä¸Š renderHistoryList ä¼šé‡ç»˜æ•´ä¸ªåˆ—è¡¨ï¼Œæ‰€ä»¥è¿™é‡Œå¯èƒ½ä¸éœ€è¦ï¼Œä½†ä¸ºäº†ä¿é™©)
            btn.textContent = originalText;
            btn.disabled = false;
        }

        async function generateTitle(sessionId) {
            const session = sessions[sessionId];
            if (!session || session.messages.length === 0) return; // åªè¦æœ‰æ¶ˆæ¯å°±å¯ä»¥ç”Ÿæˆ

            const config = getSettings();
            if (!config.apiKey) return;

            // å–å¯¹è¯çš„å‰å‡ æ¡æ¶ˆæ¯ä½œä¸ºæ‘˜è¦ä¾æ®ï¼ˆå–å‰4æ¡ï¼Œæä¾›æ›´å¤šä¸Šä¸‹æ–‡ï¼‰
            const snippet = session.messages.slice(0, 4).map(m => `${m.role === 'user'?'ç”¨æˆ·':'AI'}:${m.content}`).join('\n');

            try {
                const response = await fetch(config.apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${config.apiKey}`
                    },
                    body: JSON.stringify({
                        model: config.model,
                        messages: [
                            { role: "system", content: "è¯·ä¸ºè¿™æ®µå¯¹è¯ç”Ÿæˆä¸€ä¸ªç®€çŸ­çš„æ ‡é¢˜ï¼ˆ10å­—ä»¥å†…ï¼Œç›´æ¥è¿”å›æ ‡é¢˜ï¼Œä¸è¦åŠ å¼•å·æˆ–è§£é‡Šï¼‰ã€‚" },
                            { role: "user", content: snippet }
                        ]
                    })
                });

                if (response.ok) {
                    const data = await response.json();
                    const title = data.choices[0].message.content.trim().replace(/^["']|["']$/g, '');
                    
                    if (title && sessions[sessionId]) { // ç¡®ä¿ä¼šè¯è¿˜å­˜åœ¨
                        sessions[sessionId].title = title;
                        saveSessionsToStorage(); // è¿™ä¼šè§¦å‘åˆ—è¡¨é‡ç»˜
                    }
                }
            } catch (e) {
                console.warn('ç”Ÿæˆæ ‡é¢˜å¤±è´¥:', e);
            }
        }

        function handleKeyPress(event) {
            if (event.key === 'Enter') {
                sendMessage();
            }
        }

        // ============ å›¾ç‰‡ä¸Šä¼ åŠŸèƒ½ ============
        
        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            // éªŒè¯æ–‡ä»¶ç±»å‹
            if (!file.type.startsWith('image/')) {
                alert('è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶');
                return;
            }
            
            // éªŒè¯æ–‡ä»¶å¤§å° (æœ€å¤§ 5MB)
            if (file.size > 5 * 1024 * 1024) {
                alert('å›¾ç‰‡å¤§å°ä¸èƒ½è¶…è¿‡ 5MB');
                return;
            }
            
            selectedImage = file;
            
            // è½¬æ¢ä¸º Base64
            const reader = new FileReader();
            reader.onload = function(e) {
                selectedImageBase64 = e.target.result;
                
                // æ˜¾ç¤ºé¢„è§ˆ
                const previewContainer = document.getElementById('imagePreviewContainer');
                const previewImg = document.getElementById('imagePreview');
                previewImg.src = selectedImageBase64;
                previewContainer.style.display = 'block';
            };
            reader.readAsDataURL(file);
        }
        
        function removeImage() {
            selectedImage = null;
            selectedImageBase64 = null;
            document.getElementById('imageUpload').value = '';
            document.getElementById('imagePreviewContainer').style.display = 'none';
        }
        
        // å›¾ç‰‡ç‚¹å‡»æ”¾å¤§æŸ¥çœ‹
        function openImageModal(imgSrc) {
            let modal = document.getElementById('imageViewModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'imageViewModal';
                modal.className = 'image-modal';
                modal.innerHTML = '<img src="" alt="æŸ¥çœ‹å›¾ç‰‡">';
                modal.onclick = function() {
                    modal.classList.remove('active');
                };
                document.body.appendChild(modal);
            }
            modal.querySelector('img').src = imgSrc;
            modal.classList.add('active');
        }

        // --- è®¾ç½®ç›¸å…³é€»è¾‘ ---

        function openSettings() {
            settingsModal.style.display = 'flex';
        }

        function closeSettings() {
            settingsModal.style.display = 'none';
        }

        function switchSettingsTab(tabName, tabButton) {
            // æ›´æ–°æ ‡ç­¾é¡µæŒ‰é’®çŠ¶æ€
            document.querySelectorAll('.settings-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            if (tabButton) {
                tabButton.classList.add('active');
            }
            
            // æ›´æ–°é¢æ¿æ˜¾ç¤º
            document.querySelectorAll('.settings-panel').forEach(panel => {
                panel.classList.remove('active');
            });
            document.getElementById(`settingsPanel-${tabName}`).classList.add('active');
        }

        function openAnnouncement() {
            announcementModal.style.display = 'flex';
        }

        function closeAnnouncement() {
            announcementModal.style.display = 'none';
        }

        function saveSettings() {
            const apiUrlValue = DEFAULT_CONFIG.apiUrl;

            // ğŸ”’ å®‰å…¨éªŒè¯ï¼šAPI Key
            const apiKeyValue = apiKeyInput.value.trim();
            if (apiKeyValue) {
                const keyValidation = validateApiKey(apiKeyValue);
                if (!keyValidation.valid) {
                    alert('API å¯†é’¥æ— æ•ˆï¼š' + keyValidation.error);
                    return;
                }
            }

            const config = {
                apiUrl: apiUrlValue,
                apiKey: apiKeyValue || DEFAULT_CONFIG.apiKey,
                model: modelNameInput.value.trim() || DEFAULT_CONFIG.model,
                temperature: parseFloat(tempRange.value),
                contextLimit: parseInt(contextRange.value),
                titleRegenInterval: parseInt(document.getElementById('titleRegenRange').value),
                autoDeleteOldest: document.getElementById('autoDeleteOldestToggle').checked,
                stream: streamToggle.checked,
                enableMaxTokens: maxTokensToggle.checked,
                maxTokens: parseInt(maxTokensInput.value)
            };
            
            localStorage.setItem('chatConfig', JSON.stringify(config));

            const webdavConfig = getWebdavConfig();
            saveWebdavConfig({
                ...webdavConfig,
                url: webdavUrlInput.value.trim(),
                username: webdavUsernameInput.value.trim(),
                password: webdavPasswordInput.value,
                path: webdavPathInput.value.trim(),
                autoSync: webdavAutoSyncToggle.checked,
                autoSyncInterval: parseInt(webdavAutoSyncIntervalInput.value) || 30
            });
            scheduleWebdavAutoSync();

            closeSettings();
            alert('é…ç½®å·²ä¿å­˜ï¼');
        }


        function applyModelPreset(presetName) {
            const preset = MODEL_PRESETS[presetName];
            if (!preset) return;

            tempRange.value = preset.temperature;
            document.getElementById('tempValue').textContent = preset.temperature;
            contextRange.value = preset.contextLimit;
            document.getElementById('contextValue').textContent = preset.contextLimit;
            document.getElementById('titleRegenRange').value = preset.titleRegenInterval;
            document.getElementById('titleRegenValue').textContent = preset.titleRegenInterval;
            streamToggle.checked = preset.stream;
            alert('å·²åº”ç”¨é¢„è®¾ï¼Œå¯ç»§ç»­è°ƒæ•´åä¿å­˜ã€‚');
        }

        function getModelProfiles() {
            return JSON.parse(localStorage.getItem('modelProfiles') || '[]');
        }

        function renderModelProfiles() {
            const profiles = getModelProfiles();
            profileSelect.innerHTML = '';
            if (profiles.length === 0) {
                profileSelect.innerHTML = '<option value="">æš‚æ— å·²ä¿å­˜æ–¹æ¡ˆ</option>';
                return;
            }

            profileSelect.innerHTML = '<option value="">è¯·é€‰æ‹©æ–¹æ¡ˆ</option>';
            profiles.forEach(profile => {
                const option = document.createElement('option');
                option.value = profile.name;
                option.textContent = profile.name;
                profileSelect.appendChild(option);
            });
        }

        function saveModelProfile() {
            const name = profileNameInput.value.trim();
            if (!name) {
                alert('è¯·å…ˆè¾“å…¥æ–¹æ¡ˆåç§°');
                return;
            }

            const profiles = getModelProfiles().filter(item => item.name !== name);
            profiles.push({
                name,
                model: modelNameInput.value.trim(),
                temperature: parseFloat(tempRange.value),
                contextLimit: parseInt(contextRange.value),
                titleRegenInterval: parseInt(document.getElementById('titleRegenRange').value),
                stream: streamToggle.checked,
                enableMaxTokens: maxTokensToggle.checked,
                maxTokens: parseInt(maxTokensInput.value) || DEFAULT_CONFIG.maxTokens
            });
            localStorage.setItem('modelProfiles', JSON.stringify(profiles));
            renderModelProfiles();
            profileSelect.value = name;
            alert('æ¨¡å‹æ–¹æ¡ˆå·²ä¿å­˜');
        }

        function loadModelProfile() {
            const selectedName = profileSelect.value;
            if (!selectedName) {
                alert('è¯·å…ˆé€‰æ‹©æ–¹æ¡ˆ');
                return;
            }

            const profile = getModelProfiles().find(item => item.name === selectedName);
            if (!profile) return;

            modelNameInput.value = profile.model || DEFAULT_CONFIG.model;
            tempRange.value = profile.temperature ?? DEFAULT_CONFIG.temperature;
            document.getElementById('tempValue').textContent = tempRange.value;
            contextRange.value = profile.contextLimit ?? DEFAULT_CONFIG.contextLimit;
            document.getElementById('contextValue').textContent = contextRange.value;
            document.getElementById('titleRegenRange').value = profile.titleRegenInterval ?? 5;
            document.getElementById('titleRegenValue').textContent = document.getElementById('titleRegenRange').value;
            streamToggle.checked = profile.stream ?? DEFAULT_CONFIG.stream;
            maxTokensToggle.checked = profile.enableMaxTokens ?? DEFAULT_CONFIG.enableMaxTokens;
            maxTokensInput.value = profile.maxTokens ?? DEFAULT_CONFIG.maxTokens;
            maxTokensInput.style.display = maxTokensToggle.checked ? 'block' : 'none';
            alert('å·²åŠ è½½æ¨¡å‹æ–¹æ¡ˆ');
        }

        function deleteModelProfile() {
            const selectedName = profileSelect.value;
            if (!selectedName) {
                alert('è¯·å…ˆé€‰æ‹©æ–¹æ¡ˆ');
                return;
            }
            const profiles = getModelProfiles().filter(item => item.name !== selectedName);
            localStorage.setItem('modelProfiles', JSON.stringify(profiles));
            renderModelProfiles();
            alert('å·²åˆ é™¤æ–¹æ¡ˆ');
        }

        async function testApiConnection(btn) {
            const apiKey = apiKeyInput.value.trim();
            if (!apiKey) {
                alert('è¯·å…ˆè¾“å…¥ API å¯†é’¥');
                return;
            }

            apiConnectionStatus.textContent = 'è¿æ¥æµ‹è¯•ä¸­...';
            apiConnectionStatus.style.color = '#055160';
            btn.disabled = true;
            const originalText = btn.textContent;
            btn.textContent = 'æµ‹è¯•ä¸­...';

            try {
                await fetchModelsWithKey(apiKey);
                apiConnectionStatus.textContent = 'è¿æ¥æˆåŠŸ';
                apiConnectionStatus.style.color = '#0f5132';
            } catch (error) {
                apiConnectionStatus.textContent = `è¿æ¥å¤±è´¥ï¼š${error.message}`;
                apiConnectionStatus.style.color = '#842029';
            } finally {
                btn.disabled = false;
                btn.textContent = originalText;
            }
        }

        function scheduleWebdavAutoSync() {
            if (webdavAutoSyncTimer) {
                clearInterval(webdavAutoSyncTimer);
                webdavAutoSyncTimer = null;
            }

            const cfg = getWebdavConfig();
            if (!cfg.autoSync) return;

            const intervalMinutes = Math.max(5, parseInt(cfg.autoSyncInterval) || 30);
            webdavAutoSyncTimer = setInterval(() => {
                syncWebdavNow();
            }, intervalMinutes * 60 * 1000);
        }

        function exportLocalBackup() {
            const payload = {
                exportedAt: new Date().toISOString(),
                chatSessions: JSON.parse(localStorage.getItem('chatSessions') || '{}'),
                imageGenHistory: JSON.parse(localStorage.getItem('imageGenHistory') || '[]'),
                chatConfig: getSettings()
            };

            const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            const ts = new Date().toISOString().replace(/[:.]/g, '-');
            a.href = url;
            a.download = `echoai-backup-${ts}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function importLocalBackup(event) {
            const file = event.target.files && event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = () => {
                try {
                    const data = JSON.parse(reader.result);
                    if (data.chatSessions) {
                        localStorage.setItem('chatSessions', JSON.stringify(data.chatSessions));
                    }
                    if (Array.isArray(data.imageGenHistory)) {
                        localStorage.setItem('imageGenHistory', JSON.stringify(data.imageGenHistory));
                    }
                    if (data.chatConfig) {
                        localStorage.setItem('chatConfig', JSON.stringify({ ...data.chatConfig, apiUrl: DEFAULT_CONFIG.apiUrl }));
                    }
                    alert('å¯¼å…¥æˆåŠŸï¼Œé¡µé¢å°†åˆ·æ–°ä»¥åº”ç”¨æ•°æ®ã€‚');
                    location.reload();
                } catch (error) {
                    alert('å¯¼å…¥å¤±è´¥ï¼šå¤‡ä»½æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®');
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        function getBasicAuthHeader(username, password) {
            const token = btoa(unescape(encodeURIComponent(`${username}:${password}`)));
            return `Basic ${token}`;
        }

        function normalizeWebdavPath(path) {
            const trimmed = (path || '').trim();
            if (!trimmed) return '';
            return trimmed.split('/').filter(Boolean).map(segment => encodeURIComponent(segment)).join('/');
        }

        function buildWebdavFileUrl(baseUrl, dirPath, fileName) {
            const normalizedBase = baseUrl.replace(/\/+$/, '');
            const normalizedPath = normalizeWebdavPath(dirPath);
            const dirUrl = normalizedPath ? `${normalizedBase}/${normalizedPath}` : normalizedBase;
            return `${dirUrl}/${encodeURIComponent(fileName)}`;
        }

        async function ensureWebdavDirectory(baseUrl, dirPath, authHeader) {
            const normalizedBase = baseUrl.replace(/\/+$/, '');
            const normalizedPath = normalizeWebdavPath(dirPath);
            if (!normalizedPath) return true;

            const segments = normalizedPath.split('/');
            let currentUrl = normalizedBase;

            for (const segment of segments) {
                currentUrl = `${currentUrl}/${segment}`;
                const response = await fetch(currentUrl, {
                    method: 'MKCOL',
                    headers: {
                        'Authorization': authHeader
                    }
                });

                if (response.ok) {
                    continue;
                }

                if ([405, 409, 301, 302].includes(response.status)) {
                    continue;
                }

                if (response.status === 204) {
                    continue;
                }

                throw new Error(`åˆ›å»ºç›®å½•å¤±è´¥ (HTTP ${response.status})`);
            }

            return true;
        }

        async function uploadWebdavFile(fileUrl, authHeader, content) {
            const response = await fetch(fileUrl, {
                method: 'PUT',
                headers: {
                    'Authorization': authHeader,
                    'Content-Type': 'application/json'
                },
                body: content
            });

            if (!response.ok) {
                throw new Error(`ä¸Šä¼ å¤±è´¥ (HTTP ${response.status})`);
            }
        }

        async function syncWebdavNow() {
            const urlValue = webdavUrlInput.value.trim();
            const usernameValue = webdavUsernameInput.value.trim();
            const passwordValue = webdavPasswordInput.value;
            const pathValue = webdavPathInput.value.trim();

            if (!urlValue) {
                alert('è¯·è¾“å…¥ WebDAV åœ°å€');
                return;
            }

            const urlValidation = validateUrl(urlValue);
            if (!urlValidation.valid) {
                alert('WebDAV åœ°å€æ— æ•ˆï¼š' + urlValidation.error);
                return;
            }

            if (!usernameValue) {
                alert('è¯·è¾“å…¥ WebDAV ç”¨æˆ·å');
                return;
            }

            if (!passwordValue) {
                alert('è¯·è¾“å…¥ WebDAV å¯†ç ');
                return;
            }

            const normalizedBaseUrl = urlValidation.url.replace(/\/+$/, '');
            webdavUrlInput.value = normalizedBaseUrl;

            const existingWebdav = getWebdavConfig();
            const updatedWebdavConfig = {
                url: normalizedBaseUrl,
                username: usernameValue,
                password: passwordValue,
                path: pathValue,
                lastSync: existingWebdav.lastSync || '',
                autoSync: webdavAutoSyncToggle.checked,
                autoSyncInterval: parseInt(webdavAutoSyncIntervalInput.value) || 30
            };
            const isWebdavChanged = updatedWebdavConfig.url !== existingWebdav.url
                || updatedWebdavConfig.username !== existingWebdav.username
                || updatedWebdavConfig.password !== existingWebdav.password
                || updatedWebdavConfig.path !== existingWebdav.path;

            if (isWebdavChanged) {
                updatedWebdavConfig.lastSync = '';
            }

            saveWebdavConfig(updatedWebdavConfig);
            setWebdavStatus('åŒæ­¥ä¸­...', 'loading');

            const authHeader = getBasicAuthHeader(usernameValue, passwordValue);

            try {
                await ensureWebdavDirectory(normalizedBaseUrl, pathValue, authHeader);

                const chatSessionsRaw = localStorage.getItem('chatSessions');
                const imageHistoryRaw = localStorage.getItem('imageGenHistory');

                const chatSessionsPayload = chatSessionsRaw
                    ? JSON.stringify(JSON.parse(chatSessionsRaw), null, 2)
                    : '{}';
                const imageHistoryPayload = imageHistoryRaw
                    ? JSON.stringify(JSON.parse(imageHistoryRaw), null, 2)
                    : '[]';

                await uploadWebdavFile(
                    buildWebdavFileUrl(normalizedBaseUrl, pathValue, 'echoai-chatSessions.json'),
                    authHeader,
                    chatSessionsPayload
                );

                await uploadWebdavFile(
                    buildWebdavFileUrl(normalizedBaseUrl, pathValue, 'echoai-imageGenHistory.json'),
                    authHeader,
                    imageHistoryPayload
                );

                const nowText = new Date().toLocaleString('zh-CN', { hour12: false });
                updatedWebdavConfig.lastSync = nowText;
                saveWebdavConfig(updatedWebdavConfig);

                setWebdavStatus(`å·²åŒæ­¥ï¼š${nowText}`, 'success');
                alert('WebDAV åŒæ­¥å®Œæˆ');
            } catch (error) {
                console.error('WebDAV åŒæ­¥å¤±è´¥:', error);
                setWebdavStatus(`åŒæ­¥å¤±è´¥ï¼š${error.message}`, 'error');
                alert(`WebDAV åŒæ­¥å¤±è´¥ï¼š${error.message}`);
            }
        }

        async function fetchModelsWithKey(apiKey) {
            const apiUrl = DEFAULT_CONFIG.apiUrl;
            let modelsUrl = apiUrl.replace(/\/chat\/completions\/?$/, '/models');
            if (modelsUrl === apiUrl) {
                 modelsUrl = apiUrl.replace(/\/v1\/chat\/completions\/?$/, '/v1/models');
            }
            const response = await fetch(modelsUrl, {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${apiKey}`
                }
            });
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            return response.json();
        }

        async function fetchModels() {
            const apiKey = apiKeyInput.value.trim();

            if (!apiKey) {
                alert('è¯·å…ˆè¾“å…¥ API å¯†é’¥ (API Key)');
                return;
            }

            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = 'è·å–ä¸­...';
            btn.disabled = true;

            try {
                const data = await fetchModelsWithKey(apiKey);
                const modelSelect = document.getElementById('modelSelect');
                modelSelect.innerHTML = '<option value="" disabled selected>è¯·é€‰æ‹©æ¨¡å‹...</option>';

                if (data.data && Array.isArray(data.data)) {
                    data.data.sort((a, b) => a.id.localeCompare(b.id));
                    data.data.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model.id;
                        option.textContent = model.id;
                        modelSelect.appendChild(option);
                    });
                    
                    modelSelect.style.display = 'block';
                    alert(`æˆåŠŸè·å– ${data.data.length} ä¸ªæ¨¡å‹ï¼è¯·åœ¨ä¸‹æ–¹ä¸‹æ‹‰æ¡†ä¸­é€‰æ‹©ã€‚`);
                } else {
                    alert('è·å–æˆåŠŸï¼Œä½†è¿”å›æ•°æ®æ ¼å¼ä¸ç¬¦åˆé¢„æœŸã€‚');
                }

            } catch (error) {
                console.error('Fetch Models Error:', error);
                alert(`è·å–æ¨¡å‹åˆ—è¡¨å¤±è´¥: ${error.message}\nè¯·æ£€æŸ¥ API åœ°å€æ˜¯å¦æ­£ç¡®ï¼Œæˆ–è€…è¯¥æ¥å£æ˜¯å¦æ”¯æŒ /models ç«¯ç‚¹ã€‚`);
            } finally {
                btn.textContent = originalText;
                btn.disabled = false;
            }
        }

        // --- é¡¶éƒ¨æ¨¡å‹é€‰æ‹©å™¨é€»è¾‘ ---

        let cachedModelList = null;

        async function initHeaderModelSelect() {
            const headerSelect = document.getElementById('headerModelSelect');
            const config = getSettings();
            const currentModel = config.model || DEFAULT_CONFIG.model;
            
            // å…ˆæ˜¾ç¤ºå½“å‰æ¨¡å‹
            headerSelect.innerHTML = `<option value="${currentModel}" selected>${currentModel}</option>`;
            refreshHeaderModelSelect();
            
            // å°è¯•è·å–å®Œæ•´æ¨¡å‹åˆ—è¡¨
            await fetchHeaderModels();
        }

        async function fetchHeaderModels() {
            const config = getSettings();
            const apiUrl = DEFAULT_CONFIG.apiUrl;
            const apiKey = config.apiKey || DEFAULT_CONFIG.apiKey;
            const currentModel = config.model || DEFAULT_CONFIG.model;
            
            if (!apiKey) return;
            
            let modelsUrl = apiUrl.replace(/\/chat\/completions\/?$/, '/models');
            if (modelsUrl === apiUrl) {
                modelsUrl = apiUrl.replace(/\/v1\/chat\/completions\/?$/, '/v1/models');
            }
            
            try {
                const response = await fetch(modelsUrl, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`
                    }
                });
                
                if (!response.ok) return;
                
                const data = await response.json();
                const headerSelect = document.getElementById('headerModelSelect');
                
                if (data.data && Array.isArray(data.data)) {
                    cachedModelList = data.data.map(m => m.id).sort();
                    refreshHeaderModelSelect();
                    populateImageGenModels();
                }
            } catch (e) {
                console.warn('è·å–æ¨¡å‹åˆ—è¡¨å¤±è´¥:', e);
            }
        }

        function isImageModel(modelId = '') {
            return /image|vision|flux|midjourney|sdxl|dall|paint|ç»˜å›¾/i.test(modelId);
        }

        function refreshHeaderModelSelect() {
            const headerSelect = document.getElementById('headerModelSelect');
            const config = getSettings();
            const currentModel = config.model || DEFAULT_CONFIG.model;
            const currentSession = sessions[currentSessionId];
            const imageOnly = !!currentSession?.isImageChat;
            const source = (cachedModelList && cachedModelList.length > 0) ? cachedModelList : [currentModel];
            let models = imageOnly ? source.filter(isImageModel) : [...source];

            if (models.length === 0) {
                models = [currentModel];
            }
            if (!models.includes(currentModel)) {
                models.unshift(currentModel);
            }

            headerSelect.innerHTML = '';
            models.forEach(modelId => {
                const option = document.createElement('option');
                option.value = modelId;
                option.textContent = imageOnly && !isImageModel(modelId) ? `${modelId}ï¼ˆå½“å‰ï¼‰` : modelId;
                if (modelId === currentModel) option.selected = true;
                headerSelect.appendChild(option);
            });
        }

        function onHeaderModelChange(newModel) {
            if (!newModel) return;
            
            // æ›´æ–°é…ç½®
            const config = getSettings();
            config.model = newModel;
            localStorage.setItem('chatConfig', JSON.stringify(config));
            
            // åŒæ­¥æ›´æ–°è®¾ç½®é¢æ¿ä¸­çš„æ¨¡å‹åç§°
            modelNameInput.value = newModel;
        }

        settingsModal.addEventListener('click', function(e) {
            if (e.target === settingsModal) {
                closeSettings();
            }
        });

        announcementModal.addEventListener('click', function(e) {
            if (e.target === announcementModal) {
                closeAnnouncement();
            }
        });

        if (skillTrainingModal) {
            skillTrainingModal.addEventListener('click', function(e) {
                if (e.target === skillTrainingModal) {
                    closeSkillTrainingModal();
                }
            });
        }

        if (skillTrainingInput) {
            skillTrainingInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    confirmSkillTraining();
                }
            });
        }

        // ============ å›¾ç‰‡ç”ŸæˆåŠŸèƒ½ (ä¸“ä¸šæ¨¡å¼) ============
        const imageGenModal = document.getElementById('imageGenModal');
        let lastGeneratedPrompt = '';
        let imageGenHistory = [];
        let imageGenRefImages = []; // å­˜å‚¨å¤šå¼ å‚è€ƒå›¾ Base64

        // å¤„ç†ä»¥å›¾ç”Ÿå›¾çš„å›¾ç‰‡ä¸Šä¼  (æ”¯æŒå¤šå¼ )
        function handleImageGenUpload(event) {
            const files = event.target.files;
            if (!files || files.length === 0) return;
            
            Array.from(files).forEach(file => {
                if (!file.type.startsWith('image/')) {
                    console.warn('è·³è¿‡éå›¾ç‰‡æ–‡ä»¶:', file.name);
                    return;
                }
                
                if (file.size > 5 * 1024 * 1024) {
                    alert(`å›¾ç‰‡ ${file.name} å¤§å°è¶…è¿‡ 5MBï¼Œå·²è·³è¿‡`);
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    addRefImage(e.target.result);
                };
                reader.readAsDataURL(file);
            });
            
            // æ¸…ç©º inputï¼Œä»¥ä¾¿å…è®¸é‡å¤ä¸Šä¼ åŒä¸€æ–‡ä»¶
            event.target.value = '';
        }

        function handleImageGenDrop(event) {
            event.preventDefault();
            event.stopPropagation();
            const files = event.dataTransfer?.files;
            if (!files?.length) return;
            handleImageGenUpload({ target: { files, value: '' } });
            document.getElementById('imageGenUploadArea').classList.remove('drag-over');
        }

        // æ·»åŠ å‚è€ƒå›¾
        function addRefImage(base64) {
            if (imageGenRefImages.length >= 5) {
                alert('æœ€å¤šä¸Šä¼  5 å¼ å‚è€ƒå›¾ç‰‡');
                return;
            }
            imageGenRefImages.push(base64);
            renderRefImages();
        }

        // ç§»é™¤å‚è€ƒå›¾
        function removeRefImage(index) {
            imageGenRefImages.splice(index, 1);
            renderRefImages();
        }

        // æ¸²æŸ“å‚è€ƒå›¾åˆ—è¡¨
        function renderRefImages() {
            const listEl = document.getElementById('imageGenPreviewList');
            if (imageGenRefImages.length === 0) {
                listEl.style.display = 'none';
                listEl.innerHTML = '';
                return;
            }
            
            listEl.style.display = 'flex';
            listEl.innerHTML = imageGenRefImages.map((img, index) => `
                <div class="image-gen-preview-item">
                    <img src="${img}" onclick="openImageModal('${img}')">
                    <button class="image-gen-preview-remove" onclick="removeRefImage(${index})">Ã—</button>
                </div>
            `).join('');
        }

        // å°†å½“å‰ç”Ÿæˆç»“æœä½œä¸ºå‚è€ƒå›¾
        function useAsRefImage() {
            const img = document.getElementById('generatedImage');
            if (!img.src || img.src === window.location.href) return;
            
            // è·å– Base64 (å¦‚æœå·²ç»æ˜¯ data URI) æˆ–è€…éœ€è¦è½¬æ¢ (å¦‚æœæ˜¯ URL)
            // è¿™é‡Œç®€å•å¤„ç† data URI
            if (img.src.startsWith('data:image')) {
                addRefImage(img.src);
                
                // è§†è§‰åé¦ˆ
                const btn = event.target;
                const originalText = btn.textContent;
                btn.textContent = 'âœ”ï¸ å·²æ·»åŠ ';
                setTimeout(() => btn.textContent = originalText, 1500);
            } else {
                // å¦‚æœæ˜¯ URLï¼Œå¯èƒ½éœ€è¦ canvas è½¬æ¢æˆ–è€…å†æ¬¡ fetch
                alert('ä»…æ”¯æŒ Base64 å›¾ç‰‡è½¬å‚è€ƒå›¾ (ç›®å‰)');
            }
        }

        // åŠ è½½å›¾ç‰‡ç”Ÿæˆå†å²è®°å½•
        function loadImageGenHistory() {
            const stored = localStorage.getItem('imageGenHistory');
            imageGenHistory = stored ? JSON.parse(stored) : [];
            renderImageHistory();
        }

        // ä¿å­˜å›¾ç‰‡ç”Ÿæˆå†å²è®°å½•
        function saveImageGenHistory() {
            // é™åˆ¶æœ€å¤šä¿å­˜ 50 æ¡è®°å½•
            if (imageGenHistory.length > 50) {
                imageGenHistory = imageGenHistory.slice(0, 50);
            }
            localStorage.setItem('imageGenHistory', JSON.stringify(imageGenHistory));
            renderImageHistory();
        }

        // æ·»åŠ å›¾ç‰‡åˆ°å†å²è®°å½•
        function addToImageHistory(prompt, imageUrl, model) {
            const record = {
                id: Date.now().toString(),
                prompt: prompt,
                imageUrl: imageUrl,
                model: model,
                timestamp: Date.now()
            };
            imageGenHistory.unshift(record);
            saveImageGenHistory();
        }

        // æ¸²æŸ“å›¾ç‰‡å†å²è®°å½•
        function renderImageHistory() {
            const listEl = document.getElementById('imageHistoryList');
            const emptyEl = document.getElementById('imageHistoryEmpty');
            const actionsEl = document.getElementById('imageHistoryActions');
            
            if (imageGenHistory.length === 0) {
                listEl.innerHTML = '';
                emptyEl.style.display = 'block';
                actionsEl.style.display = 'none';
                return;
            }
            
            emptyEl.style.display = 'none';
            actionsEl.style.display = 'block';
            
            listEl.innerHTML = imageGenHistory.map(record => {
                const date = new Date(record.timestamp);
                const timeStr = `${date.getMonth() + 1}/${date.getDate()} ${date.getHours()}:${String(date.getMinutes()).padStart(2, '0')}`;
                return `
                    <div class="image-history-item" onclick="viewHistoryImage('${record.id}')">
                        <img src="${record.imageUrl}" alt="${record.prompt}" loading="lazy">
                        <div class="image-history-info">
                            <div class="image-history-prompt" title="${record.prompt}">${record.prompt}</div>
                            <div class="image-history-time">${timeStr} Â· ${record.model}</div>
                            <div class="image-history-item-actions">
                                <button onclick="downloadImageHistoryItem(event, '${record.id}')">ä¸‹è½½</button>
                                <button onclick="copyImageHistoryLink(event, '${record.id}')">å¤åˆ¶é“¾æ¥</button>
                                <button onclick="deleteImageHistory(event, '${record.id}')">åˆ é™¤</button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function downloadImageHistoryItem(event, id) {
            event.stopPropagation();
            const record = imageGenHistory.find(r => r.id === id);
            if (record) downloadImageByUrl(record.imageUrl);
        }

        async function copyImageHistoryLink(event, id) {
            event.stopPropagation();
            const record = imageGenHistory.find(r => r.id === id);
            if (!record?.imageUrl) return;
            await navigator.clipboard.writeText(record.imageUrl);
            alert('å›¾ç‰‡é“¾æ¥å·²å¤åˆ¶');
        }

        // æŸ¥çœ‹å†å²å›¾ç‰‡
        function viewHistoryImage(id) {
            const record = imageGenHistory.find(r => r.id === id);
            if (record) {
                openImageModal(record.imageUrl);
            }
        }

        // åˆ é™¤å•æ¡å†å²è®°å½•
        function deleteImageHistory(event, id) {
            event.stopPropagation();
            if (confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡è®°å½•å—ï¼Ÿ')) {
                imageGenHistory = imageGenHistory.filter(r => r.id !== id);
                saveImageGenHistory();
            }
        }

        // æ¸…ç©ºæ‰€æœ‰å†å²è®°å½•
        function clearImageHistory() {
            if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰å›¾ç‰‡ç”Ÿæˆè®°å½•å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚')) {
                imageGenHistory = [];
                saveImageGenHistory();
            }
        }

        // åˆ‡æ¢å›¾ç‰‡ç”Ÿæˆæ ‡ç­¾é¡µ
        function switchImageGenTab(tabName, tabElement) {
            // æ›´æ–°æ ‡ç­¾é¡µæŒ‰é’®çŠ¶æ€
            document.querySelectorAll('.image-gen-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            if (tabElement) tabElement.classList.add('active');
            
            // æ›´æ–°é¢æ¿æ˜¾ç¤º
            document.querySelectorAll('.image-gen-panel').forEach(panel => {
                panel.classList.remove('active');
            });
            document.getElementById(`imageGenPanel-${tabName}`).classList.add('active');
        }

        function openImageGenerator() {
            imageGenModal.style.display = 'flex';
            // é‡ç½®çŠ¶æ€
            document.getElementById('imageGenLoading').style.display = 'none';
            document.getElementById('imageGenResult').style.display = 'none';
            document.getElementById('imageGenError').style.display = 'none';
            document.getElementById('generateImageBtn').disabled = false;
            switchImageGenTab('generate', document.querySelector('.image-gen-tab'));
            populateImageGenModels();
            // åŠ è½½å†å²è®°å½•
            loadImageGenHistory();
        }

        function populateImageGenModels() {
            const imageModelSelect = document.getElementById('imageGenModel');
            const config = getSettings();
            const fallback = ['gemini-3-pro-image-preview'];
            const models = (cachedModelList || []).filter(isImageModel);
            const finalModels = models.length > 0 ? models : fallback;
            imageModelSelect.innerHTML = '';
            finalModels.forEach(model => {
                const opt = document.createElement('option');
                opt.value = model;
                opt.textContent = model;
                if (model === config.model) opt.selected = true;
                imageModelSelect.appendChild(opt);
            });
        }

        function closeImageGenerator() {
            imageGenModal.style.display = 'none';
        }

        imageGenModal.addEventListener('click', function(e) {
            if (e.target === imageGenModal) {
                closeImageGenerator();
            }
        });

        const imageGenUploadArea = document.getElementById('imageGenUploadArea');
        if (imageGenUploadArea) {
            imageGenUploadArea.addEventListener('dragover', (event) => {
                event.preventDefault();
                imageGenUploadArea.classList.add('drag-over');
            });
            imageGenUploadArea.addEventListener('dragleave', () => {
                imageGenUploadArea.classList.remove('drag-over');
            });
            imageGenUploadArea.addEventListener('drop', handleImageGenDrop);
        }

        async function generateImage() {
            const prompt = document.getElementById('imageGenPrompt').value.trim();
            if (!prompt) {
                alert('è¯·è¾“å…¥å›¾ç‰‡æè¿°');
                return;
            }

            const config = getSettings();
            if (!config.apiKey) {
                alert('è¯·å…ˆåœ¨è®¾ç½®ä¸­é…ç½® API Key');
                openSettings();
                closeImageGenerator();
                return;
            }

            lastGeneratedPrompt = prompt;
            const model = document.getElementById('imageGenModel').value;
            
            // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
            document.getElementById('generateImageBtn').disabled = true;
            document.getElementById('imageGenLoading').style.display = 'flex';
            document.getElementById('imageGenResult').style.display = 'none';
            document.getElementById('imageGenError').style.display = 'none';

            try {
                // æ„å»ºæ¶ˆæ¯å†…å®¹
                let messageContent;
                if (imageGenRefImages.length > 0) {
                    // ä»¥å›¾ç”Ÿå›¾ï¼šå¤šæ¨¡æ€æ¶ˆæ¯ (æ”¯æŒå¤šå¼ )
                    messageContent = [
                        {
                            type: "text",
                            text: `è¯·å‚è€ƒæä¾›çš„å›¾ç‰‡ï¼Œç”Ÿæˆä¸€å¼ æ–°å›¾ç‰‡ï¼š${prompt}`
                        }
                    ];
                    
                    // æ·»åŠ æ‰€æœ‰å‚è€ƒå›¾
                    imageGenRefImages.forEach(img => {
                        messageContent.push({
                            type: "image_url",
                            image_url: {
                                url: img
                            }
                        });
                    });
                } else {
                    // çº¯æ–‡æœ¬ç”Ÿæˆ
                    messageContent = `è¯·ç”Ÿæˆä¸€å¼ å›¾ç‰‡ï¼š${prompt}`;
                }

                // ä½¿ç”¨éæµæ¨¡å¼è°ƒç”¨ API
                const response = await fetch(config.apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${config.apiKey}`
                    },
                    body: JSON.stringify({
                        model: model,
                        messages: [
                            {
                                role: 'user',
                                content: messageContent
                            }
                        ],
                        stream: false
                    })
                });

                if (!response.ok) {
                    const errData = await response.json().catch(() => ({}));
                    throw new Error(errData.error?.message || `HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                
                // å°è¯•ä»å“åº”ä¸­æå–å›¾ç‰‡
                let imageUrl = null;
                const content = data.choices?.[0]?.message?.content;
                
                if (content) {
                    // æ£€æŸ¥æ˜¯å¦æœ‰ base64 å›¾ç‰‡æ•°æ®
                    const base64Match = content.match(/data:image\/[^;]+;base64,[A-Za-z0-9+/=]+/);
                    if (base64Match) {
                        imageUrl = base64Match[0];
                    }
                    
                    // æ£€æŸ¥æ˜¯å¦æœ‰å›¾ç‰‡ URL
                    if (!imageUrl) {
                        const urlMatch = content.match(/https?:\/\/[^\s"'<>]+\.(png|jpg|jpeg|gif|webp)/i);
                        if (urlMatch) {
                            imageUrl = urlMatch[0];
                        }
                    }
                    
                    // æ£€æŸ¥ Markdown å›¾ç‰‡æ ¼å¼
                    if (!imageUrl) {
                        const mdMatch = content.match(/!\[.*?\]\((https?:\/\/[^\s)]+)\)/);
                        if (mdMatch) {
                            imageUrl = mdMatch[1];
                        }
                    }
                }

                // æ£€æŸ¥æ˜¯å¦æœ‰ inline_dataï¼ˆGemini æ ¼å¼ï¼‰
                const parts = data.choices?.[0]?.message?.content_parts || data.choices?.[0]?.message?.parts;
                if (parts && Array.isArray(parts)) {
                    for (const part of parts) {
                        if (part.inline_data && part.inline_data.data) {
                            const mimeType = part.inline_data.mime_type || 'image/png';
                            imageUrl = `data:${mimeType};base64,${part.inline_data.data}`;
                            break;
                        }
                    }
                }

                if (imageUrl) {
                    document.getElementById('generatedImage').src = imageUrl;
                    document.getElementById('imageGenResult').style.display = 'block';
                    // ä¿å­˜åˆ°å†å²è®°å½•
                    addToImageHistory(prompt, imageUrl, model);
                } else {
                    throw new Error('æœªèƒ½ä»å“åº”ä¸­æå–å›¾ç‰‡ï¼Œè¯·ç¡®è®¤æ¨¡å‹æ”¯æŒå›¾ç‰‡ç”ŸæˆåŠŸèƒ½');
                }

            } catch (error) {
                console.error('å›¾ç‰‡ç”Ÿæˆå¤±è´¥:', error);
                document.getElementById('imageGenErrorMsg').textContent = `ç”Ÿæˆå¤±è´¥: ${error.message}`;
                document.getElementById('imageGenError').style.display = 'block';
            } finally {
                document.getElementById('imageGenLoading').style.display = 'none';
                document.getElementById('generateImageBtn').disabled = false;
            }
        }

        function regenerateImage() {
            if (lastGeneratedPrompt) {
                document.getElementById('imageGenPrompt').value = lastGeneratedPrompt;
                generateImage();
            }
        }

        function downloadGeneratedImage() {
            const img = document.getElementById('generatedImage');
            const src = img.src;
            
            if (src.startsWith('data:')) {
                // Base64 å›¾ç‰‡
                const link = document.createElement('a');
                link.href = src;
                link.download = `ai-image-${Date.now()}.png`;
                link.click();
            } else {
                // URL å›¾ç‰‡
                window.open(src, '_blank');
            }
        }

    </script>
</body>
</html>
